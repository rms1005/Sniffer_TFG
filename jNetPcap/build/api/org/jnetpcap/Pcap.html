<!DOCTYPE HTML>
<html lang="es">
<head>
<!-- Generated by javadoc (18) on Wed Sep 14 03:01:02 CEST 2022 -->
<title>Pcap</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-09-14">
<meta name="description" content="declaration: package: org.jnetpcap, class: Pcap">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li>Nested</li>
<li><a href="#field-summary">Field</a></li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#field-detail">Field</a></li>
<li><a href="#constructor-detail">Constr</a></li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field-detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.jnetpcap</a></div>
<h1 title="Class Pcap" class="title">Class Pcap</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance">org.jnetpcap.Pcap</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">Pcap</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></span></div>
<div class="block"><P>
 This class is the main class peered with native <code>pcap_t</code> structure
 in libpcap and winpcap library impelementations. It provides a direct mapping
 of various library methods from Java.
 </P>
 <h2>Getting started</h2>
 <p>
 <code>Pcap</code> class provides several static methods which allow discovery
 of networking interfaces and then subsequently open up either
 <code>openLive</code>, <code>openDead</code> or <code>openOffline</code> pcap
 capture sessions. In all 3 cases a <code>Pcap</code> object is returned. The
 object is backed by a C <code>pcap_t</code> structure outside of java VM
 address space. Any non-static operations on the <code>Pcap</code> object, are
 translated using java JNI API into corresponding Libpcap C calls and the
 appropriate <code>pcap_t</code> C structure is supplied to complete the call.
 </p>
 <p>
 After aquiring a <code>Pcap</code> object from above mentioned static
 methods, you must call on <a href="#close()"><code>close()</code></a> call to release any Libpcap
 resources and the backing C structure. The <code>Pcap</code> object does
 implicitly call the <a href="#close()"><code>close()</code></a> method from its <a href="#finalize()"><code>finalize()</code></a> method,
 but that will only happen when the <code>Pcap</code> is garabage collected.
 Its best practice to remember to always call on <a href="#close()"><code>close()</code></a> when
 <code>Pcap</code> object and capture session is no longer needed.
 </p>
 <p>
 If <code>Pcap</code> object is closed and any of its non-static methods are
 called on, after the close, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html" title="class or interface in java.lang" class="external-link"><code>IllegalStateException</code></a> will be thrown.
 </p>
 <h3>Getting a list of network interfaces from Pcap</h3> Lets get started with
 little example on how to inquire about available interfaces, ask the user to
 pick one of those interfaces for us, open it for capture, compile and install
 a capture filter and then start processing some packets captured as a result.
 This is all loosely based on examples you will find on tcpdump.org website
 but updated for jNetPCAP. As with libpcap, we first want to find out and get
 network interface names so we can tell jNetPCAP to open one or more for
 reading. So first we inquire about the list of interfaces on the system:
 
 <pre>
 StringBuilder errbuf = new StringBuilder();
 List&lt;PcapIf&gt; ifs = new ArrayList&lt;PcapIf&gt;(); // Will hold list of devices
 int statusCode = Pcap.findAllDevs(ifs, errbuf);
 if (statusCode != Pcap.OK) {
        System.out.println(&quot;Error occured: &quot; + errbuf.toString());
        return;
 }
 // We have a list of PcapIf devices to work with now.
 
 </pre>
 
 <p>
 <b>Note:</b> the return value from <a href="#findAllDevs(java.util.List,java.lang.StringBuilder)"><code>findAllDevs(java.util.List&lt;org.jnetpcap.PcapIf&gt;, java.lang.StringBuilder)</code></a> is an integer result
 code, just like in the C counter part. The <code>ifs</code> list is filled in
 with all the network devices as found from the corresponding C structure
 <code>pcap_if</code> linked list returned from the C function call
 findAllDevs.
 </p>
 <p>
 Now that we have a list of devices, we we print out the list of them and ask
 the user to pick one to open for capture:
 
 <pre>
 for (int i = 0; i &lt; ifs.size(); i++) {
        System.out.println(&quot;#&quot; + i + &quot;: &quot; + ifs.get(i).getName());
 }
 
 String l = System.in.readline().trim();
 Integer i = Integer.valueOf(l);
 
 PcapIf netInterface = ifs.get(i);
 </pre>
 
 <h3>Opening a network interface for live capture</h3>
 Next we open up a live capture from the network interface using
 <a href="#openLive(java.lang.String,int,int,int,java.lang.StringBuilder)"><code>openLive(String, int, int, int, StringBuilder)</code></a>:
 
 <pre>
 int snalen = 2048; // Truncate packet at this size
 
 int promiscous = Pcap.MODE_PROMISCUOUS;
 
 int timeout = 60 * 1000; // In milliseconds
 
 Pcap pcap = Pcap.openLive(netInterface.getName(),
                snaplen,
                promiscous,
                timeout,
                errbuf);
 </pre>
 
 Last argument is a buffer that will hold an error string, if error occures.
 On error <code>openLive</code> will return null.
 <h3>Compiling and applying a filter to network interface</h3>
 Once we have an open interface for capture we can apply a filter to reduce
 amount of packets captured to something that is interesting to us:
 
 <pre>
 PcapBpfProgram filter = new PcapBpfProgram();
 String expression = &quot;port 23&quot;
 int optimize = 0; // 1 means true, 0 means false
 int netmask = 0;
 
 int r = pcap.compile(filter, expression, optimize, netmask);
 if (r != Pcap.OK) {
   System.out.println(&quot;Filter error: &quot; + pcap.getErr());
 }
 pcap.setFilter(filter);
 </pre>
 
 <p>
 If filter expression contained a syntax error, the return code will be -1 and
 exact error message can be retrieved using <a href="#getErr()"><code>getErr()</code></a> method.
 </p>
 <p>
 <b>Note of caution:</b> the <code>PcapBpfProgram</code> at the top of the
 previous code section, can not be accessed until successfully filled in with
 values in the <code>pcap.compile</code> code. If you try and access any of
 its methods an <code>IllegalStateException</code> will be thrown. Only after
 a successful call to <code>compile</code> does the object become usable. The
 object is peered with C structure and until properly intialized, can not be
 accessed from java.
 </p>
 <h3>Dispatcher to receive packets as they arrive</h3> And lastly lets do
 something with the data.
 
 <pre>
 PcapHandler&lt;PrintStream&gt; handler = new PcapHandler&lt;PrintStream&gt;() {
 
        public void newPacket(PrintStream out,
                        int caplen,
                        int len,
                        int seconds,
                        int usecs,
                        ByteBuffer buffer) {
 
                out.println(&quot;Packet captured on: &quot; + new Date(seconds * 1000).toString());
        }
 };
 
 int cnt = 10; // Capture packet count
 PrintStream out = System.out; // Our custom object to send into the handler
 
 pcap.loop(cnt, handler, out); // Each packet will be dispatched to the handler
 
 pcap.close();
 </pre>
 
 <p>
 This sets up PCAP to capture 10 packets and notify our handler of each packet
 as each one is captured. Then after 10 packets the loop exits and we call
 pcap.close() to free up all the resources and we can safely throw away our
 pcap object. Also you may be curious why we pass System.out as userData to
 the loop handler. This is simply to demonstrate the typical usage for this
 kind of parameter. In our case we could easily pass a different PrintStream
 bound to lets say a network socket and our handler would produce output to
 it.
 </p>
 <p>
 Alternative way of capturing packets from any of the open pcap sessions is to
 use <a href="#dispatch(int,org.jnetpcap.packet.PcapPacketHandler,T)"><code>dispatch(int, PcapPacketHandler, Object)</code></a> method, which works
 very similarly to <a href="#loop(int,org.jnetpcap.packet.PcapPacketHandler,T)"><code>loop(int, PcapPacketHandler, Object)</code></a>. You can also
 use <a href="#next(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)"><code>next(PcapHeader, JBuffer)</code></a> and
 <a href="#nextEx(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)"><code>nextEx(PcapHeader, JBuffer)</code></a> methods which will deliver 1 packet at a
 time.
 </p>
 <h3>No packet data copies!</h3>
 <p>
 The packet data is delivered in a <code>java.nio.ByteBuffer</code>. The data
 is not copied into the buffer, but a direct byte buffer is allocated and
 wrapped around the packet data as returned from libpcap. No in memory copies
 are performed, so if the native operating system supports no-copy packet
 captures, the packet are delived to Java without copies. Only a single
 ByteBuffer object allocation is incured.
 </p>
 <h3>Omitted methods from standard lipcap API</h3> Certain deprecated methods
 from libpcap API have been omitted such as <code>lookupDev</code>,
 <code>lookupNet</code>. Also any methods that return <code>FILE *</code>
 since that is not appropriate for java environment. <h3>Multithreading issues
 </h3>
 <p>
 <code>Pcap</code> class does not provide any multithreading capabilities. As
 a pure wrapper for native <em>libpcap</em> library, <code>Pcap</code> does
 not provide any additional locking or multithreaded paradigms. The most
 suggesting method is the <a href="#breakloop()"><code>breakloop()</code></a>, which can only be used from
 another thread. This is the extent of <code>Pcap</code>'s multithreading
 capabilities and threads have to be synchronized externally. Extrememe care
 must be taken, to ensure that no two methods are in use at the same time,
 with the exception of <code>breakloop()</code>. For example, calling on
 <a href="#close()"><code>close()</code></a> while a loop is still in progress will cause
 <em>libpcap</em> libpcap to crash or coredump which will also crash the
 entire Java VM.
 </p></div>
<dl class="notes">
<dt>Author:</dt>
<dd>Mark Bednarczyk, Sly Technologies, Inc.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="caption"><span>Fields</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Field</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DEFAULT_PROMISC" class="member-name-link">DEFAULT_PROMISC</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default capture promiscous mode to be used (default:.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#DEFAULT_SNAPLEN" class="member-name-link">DEFAULT_SNAPLEN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Default capture SNAP len to be used (default: 65536).</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#DEFAULT_TIMEOUT" class="member-name-link">DEFAULT_TIMEOUT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Default capture timeout (default: 0).</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#DISPATCH_BUFFER_FULL" class="member-name-link">DISPATCH_BUFFER_FULL</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Value of packet count argument for <code>dispatch</code> method call which
 indicates that only as many packets should be returned as will fit in a
 single buffer , unless an error occured or <code>breakloop</code> call was
 used to interrupt the dispatcher.</div>
</div>
<div class="col-first even-row-color"><code>static final <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color"><code><a href="#JNETPCAP_LIBRARY_NAME" class="member-name-link">JNETPCAP_LIBRARY_NAME</a></code></div>
<div class="col-last even-row-color">
<div class="block">Name of the native library that wraps around libpcap and extensions.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOOP_INFINATE" class="member-name-link">LOOP_INFINATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">The constant name is miss-spelled.</div>
</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#LOOP_INFINITE" class="member-name-link">LOOP_INFINITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#LOOP_INTERRUPTED" class="member-name-link">LOOP_INTERRUPTED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Pcap status return code for <code>loop</code> and <code>dispatch</code>
 methods.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MODE_BLOCKING" class="member-name-link">MODE_BLOCKING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'blocking' mode.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MODE_NON_BLOCKING" class="member-name-link">MODE_NON_BLOCKING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'non-blocking' mode.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#MODE_NON_PROMISCUOUS" class="member-name-link">MODE_NON_PROMISCUOUS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Flag used with <code>openLive</code> to specify that the interface should
 not be put into promisuous mode, but only if poassible.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#MODE_PROMISCUOUS" class="member-name-link">MODE_PROMISCUOUS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Flag used with <code>openLive</code> to specify that the interface should
 be put into promisuous mode.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#NEXT_EX_EOF" class="member-name-link">NEXT_EX_EOF</a></code></div>
<div class="col-last even-row-color">
<div class="block">Exit code for <code>nextEx</code> method which indicates that pcap reached
 end of file while reading a 'savefile'.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#NEXT_EX_NOT_OK" class="member-name-link">NEXT_EX_NOT_OK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Exit code for <code>nextEx</code> method which indicates failure of some
 kind.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#NEXT_EX_OK" class="member-name-link">NEXT_EX_OK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Exit code for <code>nextEx</code> method which indicates success.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#NEXT_EX_TIMEDOUT" class="member-name-link">NEXT_EX_TIMEDOUT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Exit code for <code>nextEx</code> method which indicates timeout has
 expired before a packet was captured.</div>
</div>
<div class="col-first even-row-color"><code>static final int</code></div>
<div class="col-second even-row-color"><code><a href="#NOT_OK" class="member-name-link">NOT_OK</a></code></div>
<div class="col-last even-row-color">
<div class="block">Pcap status return code for most of the methods defined here.</div>
</div>
<div class="col-first odd-row-color"><code>static final int</code></div>
<div class="col-second odd-row-color"><code><a href="#OK" class="member-name-link">OK</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Pcap status return code for most of the methods defined here.</div>
</div>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E()" class="member-name-link">Pcap</a>()</code></div>
<div class="col-last even-row-color">
<div class="block">Pcap object can only be created by calling one of the static.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button><button id="method-summary-table-tab6" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab6', 3)" class="table-tab">Deprecated Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#breakloop()" class="member-name-link">breakloop</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 set a flag that will force pcap_dispatch() or pcap_loop() to return rather
 than looping.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#checkIsActive()" class="member-name-link">checkIsActive</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Checks if the current Pcap structure is active and open.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#close()" class="member-name-link">close</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">pcap_close() closes the files associated with p and deallocates resources.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#compile(org.jnetpcap.PcapBpfProgram,java.lang.String,int,int)" class="member-name-link">compile</a><wbr>(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str,
 int&nbsp;optimize,
 int&nbsp;netmask)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Compile a packet filter, converting a high level filtering expression in to
 a progra that can be interpreted by the kernel-level filtering engine.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#compileNoPcap(int,int,org.jnetpcap.PcapBpfProgram,java.lang.String,int,int)" class="member-name-link">compileNoPcap</a><wbr>(int&nbsp;snaplen,
 int&nbsp;dlt,
 <a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str,
 int&nbsp;optimize,
 int&nbsp;netmask)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">
 Compile a packet filter without the need of opening an adapter.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#datalink()" class="member-name-link">datalink</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns the link layer of an adapter.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#datalinkNameToVal(java.lang.String)" class="member-name-link">datalinkNameToVal</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Translates a data link type name, which is a DLT_ name with the DLT_
 removed, to the corresponding data link type value.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#datalinkValToDescription(int)" class="member-name-link">datalinkValToDescription</a><wbr>(int&nbsp;dlt)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Translates a data link type value to a short description of that data link
 type.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#datalinkValToName(int)" class="member-name-link">datalinkValToName</a><wbr>(int&nbsp;dlt)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Translates a data link type value to the corresponding data link type name.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,int,org.jnetpcap.packet.JPacketHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,int,org.jnetpcap.packet.PcapPacketHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,org.jnetpcap.ByteBufferHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,org.jnetpcap.JBufferHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,org.jnetpcap.packet.JPacketHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,org.jnetpcap.packet.JPacketHandler,T,org.jnetpcap.packet.JScanner)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#dispatch(int,org.jnetpcap.packet.PcapPacketHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#dispatch(int,org.jnetpcap.packet.PcapPacketHandler,T,org.jnetpcap.packet.JScanner)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dispatch(int,org.jnetpcap.PcapDumper)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a>&nbsp;dumper)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">A specialized dispatch method that utilizes a fast native dumper without
 entering java environment.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#dispatch(int,org.jnetpcap.PcapHandler,T)" class="member-name-link">dispatch</a><wbr>(int&nbsp;cnt,
 <a href="PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#dumpOpen(java.lang.String)" class="member-name-link">dumpOpen</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;fname)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Open a file to write packets.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>protected void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#finalize()" class="member-name-link">finalize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Cleanup before we're GCed.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#findAllDevs(java.util.List,java.lang.StringBuilder)" class="member-name-link">findAllDevs</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">pcap_findalldevs() constructs a list of network devices that can be opened
 with pcap_open_live().</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#freeAllDevs(java.util.List,byte%5B%5D)" class="member-name-link">freeAllDevs</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 byte[]&nbsp;errbuf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of byte[] errbuf is discouraged</div>
</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#freeAllDevs(java.util.List,java.lang.StringBuilder)" class="member-name-link">freeAllDevs</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This method does nothing. jNetPcap implementation frees up the device list
 immediately after its copied into Java objects in java space.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static void</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#freecode(org.jnetpcap.PcapBpfProgram)" class="member-name-link">freecode</a><wbr>(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">This frees up the code structures, but does not released the peered base
 bpf_program peer structure.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getErr()" class="member-name-link">getErr</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">return the error text pertaining to the last pcap library error.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getNonBlock(java.lang.StringBuilder)" class="member-name-link">getNonBlock</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">pcap_getnonblock() returns the current ``non-blocking'' state of the
 capture descriptor; it always returns 0 on ``savefiles''.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#inject(byte%5B%5D)" class="member-name-link">inject</a><wbr>(byte[]&nbsp;buf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#inject(byte%5B%5D,int,int)" class="member-name-link">inject</a><wbr>(byte[]&nbsp;buf,
 int&nbsp;offset,
 int&nbsp;length)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#inject(java.nio.ByteBuffer)" class="member-name-link">inject</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#inject(org.jnetpcap.nio.JBuffer,int,int)" class="member-name-link">inject</a><wbr>(<a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buf,
 int&nbsp;start,
 int&nbsp;len)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Private method to perform work.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isInjectSupported()" class="member-name-link">isInjectSupported</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Checks if the current platform has support for pcap_inject call.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#isSendPacketSupported()" class="member-name-link">isSendPacketSupported</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Checks if the current platform has support for pcap_sendpacket call.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#isSwapped()" class="member-name-link">isSwapped</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">returns true if the current savefile uses a different byte order than the
 current system.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#libVersion()" class="member-name-link">libVersion</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a pointer to a string giving information about the version of the
 libpcap library being used; note that it contains more information than
 just a version number.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#lookupDev(java.lang.StringBuilder)" class="member-name-link">lookupDev</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns a network device suitable for use with <code>openLive</code> and
 <code>lookupNet</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#lookupNet(java.lang.String,org.jnetpcap.nio.JNumber,org.jnetpcap.nio.JNumber,java.lang.StringBuilder)" class="member-name-link">lookupNet</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 <a href="nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</a>&nbsp;netp,
 <a href="nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</a>&nbsp;maskp,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Determines the network number and mask associated with the network device.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6"><code>static int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#lookupNet(java.lang.String,org.jnetpcap.PcapInteger,org.jnetpcap.PcapInteger,java.lang.StringBuilder)" class="member-name-link">lookupNet</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 <a href="PcapInteger.html" title="class in org.jnetpcap">PcapInteger</a>&nbsp;netp,
 <a href="PcapInteger.html" title="class in org.jnetpcap">PcapInteger</a>&nbsp;maskp,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapInteger has been deprecated</div>
</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,int,org.jnetpcap.packet.JPacketHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,int,org.jnetpcap.packet.PcapPacketHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.ByteBufferHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.JBufferHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.packet.JPacketHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.packet.JPacketHandler,T,org.jnetpcap.packet.JScanner)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.packet.PcapPacketHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.packet.PcapPacketHandler,T,org.jnetpcap.packet.JScanner)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#loop(int,org.jnetpcap.PcapDumper)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a>&nbsp;dumper)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">A specialized loop method that utilizes a fast native dumper without
 entering java environment.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code>&lt;T&gt;&nbsp;int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#loop(int,org.jnetpcap.PcapHandler,T)" class="member-name-link">loop</a><wbr>(int&nbsp;cnt,
 <a href="PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#majorVersion()" class="member-name-link">majorVersion</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Return the major version number of the pcap library used to write the
 savefile.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#minorVersion()" class="member-name-link">minorVersion</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Return the minor version number of the pcap library used to write the
 savefile.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#next(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">next</a><wbr>(<a href="PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;pkt_header,
 <a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Return the next available packet. pcap_next() reads the next packet (by
 calling pcap_dispatch() with a cnt of 1) and returns a u_char pointer to
 the data in that packet.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#next(org.jnetpcap.PcapPktHdr)" class="member-name-link">next</a><wbr>(<a href="PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</a>&nbsp;pkt_header)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapPktHdr has been replaced with PcapHeader</div>
</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#nextEx(org.jnetpcap.packet.PcapPacket)" class="member-name-link">nextEx</a><wbr>(<a href="packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">
 Read a packet from an interface or from an offline capture.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#nextEx(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">nextEx</a><wbr>(<a href="PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;pkt_header,
 <a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Read a packet from an interface or from an offline capture.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6"><code><a href="#nextEx(org.jnetpcap.PcapPktHdr,org.jnetpcap.PcapPktBuffer)" class="member-name-link">nextEx</a><wbr>(<a href="PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</a>&nbsp;pkt_header,
 <a href="PcapPktBuffer.html" title="class in org.jnetpcap">PcapPktBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4 method-summary-table-tab6">
<div class="block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use PcapHeader and PcapPktBuffer has been deprecated</div>
</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#openDead(int,int)" class="member-name-link">openDead</a><wbr>(int&nbsp;linktype,
 int&nbsp;snaplen)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Create a pcap_t structure without starting a capture. pcap_open_dead() is
 used for creating a pcap_t structure to use when calling the other
 functions in libpcap.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#openLive(java.lang.String,int,int,int,java.lang.StringBuilder)" class="member-name-link">openLive</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 int&nbsp;snaplen,
 int&nbsp;promisc,
 int&nbsp;timeout,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">
 Open a live capture associated with the specified network interface device.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#openOffline(java.lang.String,java.lang.StringBuilder)" class="member-name-link">openOffline</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;fname,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Open a savefile in the tcpdump/libpcap format to read packets.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#sendPacket(byte%5B%5D)" class="member-name-link">sendPacket</a><wbr>(byte[]&nbsp;buf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#sendPacket(byte%5B%5D,int,int)" class="member-name-link">sendPacket</a><wbr>(byte[]&nbsp;buf,
 int&nbsp;offset,
 int&nbsp;length)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#sendPacket(java.nio.ByteBuffer)" class="member-name-link">sendPacket</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#sendPacket(org.jnetpcap.nio.JBuffer)" class="member-name-link">sendPacket</a><wbr>(<a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">This method allows to send a raw packet to the network.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setDatalink(int)" class="member-name-link">setDatalink</a><wbr>(int&nbsp;dlt)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Set the current data link type of the pcap descriptor to the type specified
 by dlt.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setFilter(org.jnetpcap.PcapBpfProgram)" class="member-name-link">setFilter</a><wbr>(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Associate a filter to a capture. pcap_setfilter() is used to specify a
 filter program. fp is a pointer to a bpf_program struct, usually the result
 of a call to pcap_compile(). -1 is returned on failure, in which case
 pcap_geterr() may be used to display the error text; 0 is returned on
 success.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#setNonBlock(int,java.lang.StringBuilder)" class="member-name-link">setNonBlock</a><wbr>(int&nbsp;nonBlock,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">pcap_setnonblock() puts a capture descriptor, opened with pcap_open_live(),
 into ``non-blocking'' mode, or takes it out of ``non-blocking'' mode,
 depending on whether the nonblock argument is non-zero or zero.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#snapshot()" class="member-name-link">snapshot</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Return the dimension of the packet portion (in bytes) that is delivered to
 the application. pcap_snapshot() returns the snapshot length specified when
 pcap_open_live was called.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#stats(org.jnetpcap.PcapStat)" class="member-name-link">stats</a><wbr>(<a href="PcapStat.html" title="class in org.jnetpcap">PcapStat</a>&nbsp;stats)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns statistics on the current capture.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#toString()" class="member-name-link">toString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Prints libVersion that Pcap is based on.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field-detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="DEFAULT_PROMISC">
<h3>DEFAULT_PROMISC</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DEFAULT_PROMISC</span></div>
<div class="block">Default capture promiscous mode to be used (default:.
 1)</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_PROMISC">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DEFAULT_SNAPLEN">
<h3>DEFAULT_SNAPLEN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DEFAULT_SNAPLEN</span></div>
<div class="block">Default capture SNAP len to be used (default: 65536).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_SNAPLEN">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DEFAULT_TIMEOUT">
<h3>DEFAULT_TIMEOUT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DEFAULT_TIMEOUT</span></div>
<div class="block">Default capture timeout (default: 0).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_TIMEOUT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="DISPATCH_BUFFER_FULL">
<h3>DISPATCH_BUFFER_FULL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">DISPATCH_BUFFER_FULL</span></div>
<div class="block">Value of packet count argument for <code>dispatch</code> method call which
 indicates that only as many packets should be returned as will fit in a
 single buffer , unless an error occured or <code>breakloop</code> call was
 used to interrupt the dispatcher. Note, that this constant is only
 appropriate value for <code>dispatch</code> method call. Loop method uses
 LOOP_INFINATE for something similar, but definately not identical to this
 option.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.DISPATCH_BUFFER_FULL">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="JNETPCAP_LIBRARY_NAME">
<h3>JNETPCAP_LIBRARY_NAME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">JNETPCAP_LIBRARY_NAME</span></div>
<div class="block">Name of the native library that wraps around libpcap and extensions.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.JNETPCAP_LIBRARY_NAME">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOOP_INFINATE">
<h3>LOOP_INFINATE</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOOP_INFINATE</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">The constant name is miss-spelled. You should use the correctly
             spelled constant LOOP_INFINITE</div>
</div>
<div class="block">Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher. Note,
 that this constant is not appropriate value for <code>dispatch</code>
 method call, which has a different meaning.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#LOOP_INFINITE"><code>LOOP_INFINITE</code></a></li>
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INFINATE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOOP_INFINITE">
<h3>LOOP_INFINITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOOP_INFINITE</span></div>
<div class="block">Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher. Note,
 that this constant is not appropriate value for <code>dispatch</code>
 method call, which has a different meaning.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INFINITE">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="LOOP_INTERRUPTED">
<h3>LOOP_INTERRUPTED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">LOOP_INTERRUPTED</span></div>
<div class="block">Pcap status return code for <code>loop</code> and <code>dispatch</code>
 methods. This status code indicates that the the dispatcher was interrupted
 by a call to <code>breakloop</code> call.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INTERRUPTED">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MODE_BLOCKING">
<h3>MODE_BLOCKING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MODE_BLOCKING</span></div>
<div class="block">Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'blocking' mode. The flag can also
 be the return code from <code>getNonBlock</code>. The flag has no affect on
 'savefiles'.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.MODE_BLOCKING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MODE_NON_BLOCKING">
<h3>MODE_NON_BLOCKING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MODE_NON_BLOCKING</span></div>
<div class="block">Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'non-blocking' mode. The flag can
 also be the return code from <code>getNonBlock</code>. The flag has no
 affect on 'savefiles'.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.MODE_NON_BLOCKING">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MODE_NON_PROMISCUOUS">
<h3>MODE_NON_PROMISCUOUS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MODE_NON_PROMISCUOUS</span></div>
<div class="block">Flag used with <code>openLive</code> to specify that the interface should
 not be put into promisuous mode, but only if poassible. Note, the even
 though the flag is specified, the interface could still be opened in
 promiscous mode for other reasons, such as a different process had already
 put the interface into promiscuous mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.MODE_NON_PROMISCUOUS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="MODE_PROMISCUOUS">
<h3>MODE_PROMISCUOUS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">MODE_PROMISCUOUS</span></div>
<div class="block">Flag used with <code>openLive</code> to specify that the interface should
 be put into promisuous mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.MODE_PROMISCUOUS">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="NEXT_EX_EOF">
<h3>NEXT_EX_EOF</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">NEXT_EX_EOF</span></div>
<div class="block">Exit code for <code>nextEx</code> method which indicates that pcap reached
 end of file while reading a 'savefile'.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_EOF">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="NEXT_EX_NOT_OK">
<h3>NEXT_EX_NOT_OK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">NEXT_EX_NOT_OK</span></div>
<div class="block">Exit code for <code>nextEx</code> method which indicates failure of some
 kind. Use <a href="#getErr()"><code>getErr()</code></a> to retrieve the error message.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_NOT_OK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="NEXT_EX_OK">
<h3>NEXT_EX_OK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">NEXT_EX_OK</span></div>
<div class="block">Exit code for <code>nextEx</code> method which indicates success.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_OK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="NEXT_EX_TIMEDOUT">
<h3>NEXT_EX_TIMEDOUT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">NEXT_EX_TIMEDOUT</span></div>
<div class="block">Exit code for <code>nextEx</code> method which indicates timeout has
 expired before a packet was captured. The packet header and packet buffer
 do no point to any valid data.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_TIMEDOUT">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="NOT_OK">
<h3>NOT_OK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">NOT_OK</span></div>
<div class="block">Pcap status return code for most of the methods defined here. All methods
 that return an intenger as a status code, use this constants as meaning the
 call failed.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.NOT_OK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="OK">
<h3>OK</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">OK</span></div>
<div class="block">Pcap status return code for most of the methods defined here. All methods
 that return an intenger as a status code, use this constants as meaning the
 call succeeded.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../constant-values.html#org.jnetpcap.Pcap.OK">Constant Field Values</a></li>
</ul>
</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;()">
<h3>Pcap</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">Pcap</span>()</div>
<div class="block">Pcap object can only be created by calling one of the static.
 
 <a href="#openLive(java.lang.String,int,int,int,java.lang.StringBuilder)"><code>openLive(java.lang.String, int, int, int, java.lang.StringBuilder)</code></a> methods.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="compileNoPcap(int,int,org.jnetpcap.PcapBpfProgram,java.lang.String,int,int)">
<h3>compileNoPcap</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">compileNoPcap</span><wbr><span class="parameters">(int&nbsp;snaplen,
 int&nbsp;dlt,
 <a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str,
 int&nbsp;optimize,
 int&nbsp;netmask)</span></div>
<div class="block"><p>
 Compile a packet filter without the need of opening an adapter. This
 function converts an high level filtering expression (see Filtering
 expression syntax) in a program that can be interpreted by the kernel-level
 filtering engine.
 </p>
 <p>
 pcap_compile_nopcap() is similar to pcap_compile() except that instead of
 passing a pcap structure, one passes the snaplen and linktype explicitly.
 It is intended to be used for compiling filters for direct BPF usage,
 without necessarily having called pcap_open(). (pcap_compile_nopcap() is a
 wrapper around pcap_open_dead(), pcap_compile(), and pcap_close(); the
 latter three routines can be used directly in order to get the error text
 for a compilation error.)
 </p>
 <p>
 Look at the Filtering expression syntax section for details on the str
 parameter.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>snaplen</code> - generate code to truncate packets to this length upon a match</dd>
<dd><code>dlt</code> - the first header type within the packet, or data link type of the
          interface</dd>
<dd><code>program</code> - initially empty, but after the method call will contain the
          compiled BPF program</dd>
<dd><code>str</code> - a string containing the textual expression to be compiled</dd>
<dd><code>optimize</code> - 1 means to do optimizations, any other value means no</dd>
<dd><code>netmask</code> - netmask needed to determine the broadcast address</dd>
<dt>Returns:</dt>
<dd>a return of -1 indicates an error; the error text is unavailable;
         lastly, the compiled program is stored and therefore returned in
         the formal parameter <code>program</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="datalinkNameToVal(java.lang.String)">
<h3>datalinkNameToVal</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">datalinkNameToVal</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Translates a data link type name, which is a DLT_ name with the DLT_
 removed, to the corresponding data link type value. The translation is
 case-insensitive. -1 is returned on failure.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - data link type name</dd>
<dt>Returns:</dt>
<dd>data link type value or -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="datalinkValToDescription(int)">
<h3>datalinkValToDescription</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">datalinkValToDescription</span><wbr><span class="parameters">(int&nbsp;dlt)</span></div>
<div class="block">Translates a data link type value to a short description of that data link
 type. NULL is returned on failure.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dlt</code> - data link type value</dd>
<dt>Returns:</dt>
<dd>short description of that data link type, NULL is returned on
         failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="datalinkValToName(int)">
<h3>datalinkValToName</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">datalinkValToName</span><wbr><span class="parameters">(int&nbsp;dlt)</span></div>
<div class="block">Translates a data link type value to the corresponding data link type name.
 NULL is returned on failure.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dlt</code> - data link type value</dd>
<dt>Returns:</dt>
<dd>data link type value to the corresponding data link type name, NULL
         is returned on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="findAllDevs(java.util.List,java.lang.StringBuilder)">
<h3>findAllDevs</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">findAllDevs</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">pcap_findalldevs() constructs a list of network devices that can be opened
 with pcap_open_live(). (Note that there may be network devices that cannot
 be opened with pcap_open_live() by the process calling pcap_findalldevs(),
 because, for example, that process might not have sufficient privileges to
 open them for capturing; if so, those devices will not appear on the list.)
 alldevs is set to point to the first element of the list; each element of
 the list is of type pcap_if_t, and has the following members:
 <ul>
 <li>next if not NULL, a pointer to the next element in the list; NULL for
 the last element of the list
 <li>name a pointer to a string giving a name for the device to pass to
 pcap_open_live()
 <li>description if not NULL, a pointer to a string giving a human-readable
 description of the device
 <li>addresses a pointer to the first element of a list of addresses for the
 interface
 <li>flags interface flags: PCAP_IF_LOOPBACK set if the interface is a
 loopback interface
 </ul>
 Each element of the list of addresses is of type pcap_addr_t, and has the
 following members:
 <ul>
 <li>next if not NULL, a pointer to the next element in the list; NULL for
 the last element of the list
 <li>addr a pointer to a struct sockaddr containing an address
 <li>netmask if not NULL, a pointer to a struct sockaddr that contains the
 netmask corresponding to the address pointed to by addr
 <li>broadaddr if not NULL, a pointer to a struct sockaddr that contains the
 broadcast address corresponding to the address pointed to by addr; may be
 null if the interface doesn't support broadcasts
 <li>dstaddr if not NULL, a pointer to a struct sockaddr that contains the
 destination address corresponding to the address pointed to by addr; may be
 null if the interface isn't a point-to-point interface
 </ul></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>alldevs</code> - the list is filled in with <code>PcapIf</code> interface objects;
          the list must not be immutable</dd>
<dd><code>errbuf</code> - error buffer containing error message as a string on failure</dd>
<dt>Returns:</dt>
<dd>-1 is returned on failure, in which case errbuf is filled in with
         an appropriate error message; 0 is returned on success</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="freeAllDevs(java.util.List,byte[])">
<h3>freeAllDevs</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">freeAllDevs</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 byte[]&nbsp;errbuf)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of byte[] errbuf is discouraged</div>
</div>
<div class="block">This method does nothing. jNetPcap implementation frees up the device list
 immediately after its copied into Java objects in java space. The source
 structures are immediately released. pcap_freealldevs() is used to free a
 list allocated by pcap_findalldevs().</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>alldevs</code> - is set to point to the first element of the list; each element of
          the list is of type PcapIf</dd>
<dd><code>errbuf</code> - error buffer containing error message as a string on failure</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#freeAllDevs(java.util.List,java.lang.StringBuilder)"><code>freeAllDevs(List, StringBuilder)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="freeAllDevs(java.util.List,java.lang.StringBuilder)">
<h3>freeAllDevs</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">freeAllDevs</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html" title="class or interface in java.util" class="external-link">List</a>&lt;<a href="PcapIf.html" title="class in org.jnetpcap">PcapIf</a>&gt;&nbsp;alldevs,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">This method does nothing. jNetPcap implementation frees up the device list
 immediately after its copied into Java objects in java space. The source
 structures are immediately released. pcap_freealldevs() is used to free a
 list allocated by pcap_findalldevs().</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>alldevs</code> - is set to point to the first element of the list; each element of
          the list is of type PcapIf</dd>
<dd><code>errbuf</code> - error buffer containing error message as a string on failure</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="freecode(org.jnetpcap.PcapBpfProgram)">
<h3>freecode</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">freecode</span><wbr><span class="parameters">(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program)</span></div>
<div class="block">This frees up the code structures, but does not released the peered base
 bpf_program peer structure. Only the allocated storage to hold the code is
 freedup. The peered bpf_program structure is only freed when the program
 object is garbage collected.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>program</code> - program to free up the backend resources for</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isInjectSupported()">
<h3>isInjectSupported</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isInjectSupported</span>()</div>
<div class="block">Checks if the current platform has support for pcap_inject call. The
 support is libpcap version and platform dependent.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true means <a href="#inject(byte%5B%5D)"><code>inject(byte[])</code></a> is supported, otherwise not</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#inject(byte%5B%5D)"><code>inject(byte[])</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isSendPacketSupported()">
<h3>isSendPacketSupported</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">boolean</span>&nbsp;<span class="element-name">isSendPacketSupported</span>()</div>
<div class="block">Checks if the current platform has support for pcap_sendpacket call. The
 support is libpcap version and platform dependent.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true means <a href="#sendPacket(byte%5B%5D)"><code>sendPacket(byte[])</code></a> is supported, otherwise not</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#sendPacket(byte%5B%5D)"><code>sendPacket(byte[])</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="libVersion()">
<h3>libVersion</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">libVersion</span>()</div>
<div class="block">Returns a pointer to a string giving information about the version of the
 libpcap library being used; note that it contains more information than
 just a version number.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>version of the libpcap library being used</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lookupDev(java.lang.StringBuilder)">
<h3>lookupDev</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">lookupDev</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">Returns a network device suitable for use with <code>openLive</code> and
 <code>lookupNet</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>errbuf</code> - if there is an error, errbuf is filled with appropriate message</dd>
<dt>Returns:</dt>
<dd>name of the device or null on error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lookupNet(java.lang.String,org.jnetpcap.nio.JNumber,org.jnetpcap.nio.JNumber,java.lang.StringBuilder)">
<h3>lookupNet</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">lookupNet</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 <a href="nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</a>&nbsp;netp,
 <a href="nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</a>&nbsp;maskp,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">Determines the network number and mask associated with the network device.
 Both netp and maskp are integer object references whos value is set from
 within the call. This is the way that pcap natively passes back these two
 values.
 <p>
 <b>Note:</b> this method is deprecated in pcap as it can not be used to
 pass back information about IP v6 addresses.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>device</code> - device to do the lookup on</dd>
<dd><code>netp</code> - object which will contain the value of network address</dd>
<dd><code>maskp</code> - object which will contain the value of network netmask</dd>
<dd><code>errbuf</code> - any error messages if return value is -1</dd>
<dt>Returns:</dt>
<dd>0 on success otherwise -1 on error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="lookupNet(java.lang.String,org.jnetpcap.PcapInteger,org.jnetpcap.PcapInteger,java.lang.StringBuilder)">
<h3>lookupNet</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public static</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">lookupNet</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 <a href="PcapInteger.html" title="class in org.jnetpcap">PcapInteger</a>&nbsp;netp,
 <a href="PcapInteger.html" title="class in org.jnetpcap">PcapInteger</a>&nbsp;maskp,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapInteger has been deprecated</div>
</div>
<div class="block">Determines the network number and mask associated with the network device.
 Both netp and maskp are integer object references whos value is set from
 within the call. This is the way that pcap natively passes back these two
 values.
 <p>
 <b>Note:</b> this method is deprecated in pcap as it can not be used to
 pass back information about IP v6 addresses.
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>device</code> - device to do the lookup on</dd>
<dd><code>netp</code> - object which will contain the value of network address</dd>
<dd><code>maskp</code> - object which will contain the value of network netmask</dd>
<dd><code>errbuf</code> - any error messages if return value is -1</dd>
<dt>Returns:</dt>
<dd>0 on success otherwise -1 on error</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#lookupNet(java.lang.String,org.jnetpcap.nio.JNumber,org.jnetpcap.nio.JNumber,java.lang.StringBuilder)"><code>lookupNet(String, JNumber, JNumber, StringBuilder)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="openDead(int,int)">
<h3>openDead</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></span>&nbsp;<span class="element-name">openDead</span><wbr><span class="parameters">(int&nbsp;linktype,
 int&nbsp;snaplen)</span></div>
<div class="block">Create a pcap_t structure without starting a capture. pcap_open_dead() is
 used for creating a pcap_t structure to use when calling the other
 functions in libpcap. It is typically used when just using libpcap for
 compiling BPF code.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>linktype</code> - pcap DLT link type integer value</dd>
<dd><code>snaplen</code> - filters generated using the pcap structure will truncate captured
          packets to this length</dd>
<dt>Returns:</dt>
<dd>Pcap structure that can only be used to generate filter code and
         none of its other capture methods should be called or null if error
         occured</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="openLive(java.lang.String,int,int,int,java.lang.StringBuilder)">
<h3>openLive</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></span>&nbsp;<span class="element-name">openLive</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;device,
 int&nbsp;snaplen,
 int&nbsp;promisc,
 int&nbsp;timeout,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block"><p>
 Open a live capture associated with the specified network interface device.
 pcap_open_live() is used to obtain a packet capture descriptor to look at
 packets on the network. device is a string that specifies the network
 device to open; on Linux systems with 2.2 or later kernels, a device
 argument of "any" or NULL can be used to capture packets from all
 interfaces. snaplen specifies the maximum number of bytes to capture. If
 this value is less than the size of a packet that is captured, only the
 first snaplen bytes of that packet will be captured and provided as packet
 data. A value of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet. promisc specifies if the
 interface is to be put into promiscuous mode. (Note that even if this
 parameter is false, the interface could well be in promiscuous mode for
 some other reason.)
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the promisc flag is ignored. to_ms specifies the read
 timeout in milliseconds. The read timeout is used to arrange that the read
 not necessarily return immediately when a packet is seen, but that it wait
 for some amount of time to allow more packets to arrive and to read
 multiple packets from the OS kernel in one operation. Not all platforms
 support a read timeout; on platforms that don't, the read timeout is
 ignored. A zero value for to_ms, on platforms that support a read timeout,
 will cause a read to wait forever to allow enough packets to arrive, with
 no timeout. errbuf is used to return error or warning text. It will be set
 to error text when pcap_open_live() fails and returns NULL. errbuf may also
 be set to warning text when pcap_open_live() succeds; to detect this case
 the caller should store a zero-length string in errbuf before calling
 pcap_open_live() and display the warning to the user if errbuf is no longer
 a zero-length string.
 </p>
 <p>
 <b>Special note about <code>snaplen</code> argument.</b> The behaviour of
 this argument may be suprizing to some. The <code>argument</code> is only
 applied when there is a filter set using <code>setFilter</code> method
 after the <code>openLive</code> call. Otherwise snaplen, even non zero is
 ignored. This is the behavior of all BSD systems utilizing BPF and WinPcap.
 This may change in the future, but that is the current behavior. (For more
 detailed explanation and discussion please see jNetPcap website and its
 FAQs.)
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>device</code> - buffer containing a C, '\0' terminated string with the the name of
          the device</dd>
<dd><code>snaplen</code> - amount of data to capture per packet; (see special note in doc
          comments about when this argument is ignored even when non-zero)</dd>
<dd><code>promisc</code> - 1 means open in promiscious mode, a 0 means non-propmiscous</dd>
<dd><code>timeout</code> - timeout in ms</dd>
<dd><code>errbuf</code> - a buffer that will contain any error messages if the call to open
          failed</dd>
<dt>Returns:</dt>
<dd>a raw structure the data of <code>pcap_t</code> C structure as
         returned by native libpcap call to open</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="openOffline(java.lang.String,java.lang.StringBuilder)">
<h3>openOffline</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="Pcap.html" title="class in org.jnetpcap">Pcap</a></span>&nbsp;<span class="element-name">openOffline</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;fname,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">Open a savefile in the tcpdump/libpcap format to read packets.
 pcap_open_offline() is called to open a "savefile" for reading. fname
 specifies the name of the file to open. The file has the same format as
 those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for
 stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data
 from an existing open stream fp. Note that on Windows, that stream should
 be opened in binary mode. errbuf is used to return error text and is only
 set when pcap_open_offline() or pcap_fopen_offline() fails and returns
 NULL.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fname</code> - filename of the pcap file</dd>
<dd><code>errbuf</code> - any error messages in UTC8 encoding</dd>
<dt>Returns:</dt>
<dd>Pcap structure or null if error occured</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="breakloop()">
<h3>breakloop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">breakloop</span>()</div>
<div class="block"><p>
 set a flag that will force pcap_dispatch() or pcap_loop() to return rather
 than looping. They will return the number of packets that have been
 processed so far, or -2 if no packets have been processed so far. This
 routine is safe to use inside a signal handler on UNIX or a console control
 handler on Windows, as it merely sets a flag that is checked within the
 loop. The flag is checked in loops reading packets from the OS - a signal
 by itself will not necessarily terminate those loops - as well as in loops
 processing a set of packets returned by the OS. Note that if you are
 catching signals on UNIX systems that support restarting system calls after
 a signal, and calling pcap_breakloop() in the signal handler, you must
 specify, when catching those signals, that system calls should NOT be
 restarted by that signal. Otherwise, if the signal interrupted a call
 reading packets in a live capture, when your signal handler returns after
 calling pcap_breakloop(), the call will be restarted, and the loop will not
 terminate until more packets arrive and the call completes.
 </p>
 <p>
 Note: pcap_next() will, on some platforms, loop reading packets from the
 OS; that loop will not necessarily be terminated by a signal, so
 pcap_breakloop() should be used to terminate packet processing even if
 pcap_next() is being used. pcap_breakloop() does not guarantee that no
 further packets will be processed by pcap_dispatch() or pcap_loop() after
 it is called; at most one more packet might be processed. If -2 is returned
 from pcap_dispatch() or pcap_loop(), the flag is cleared, so a subsequent
 call will resume reading packets. If a positive number is returned, the
 flag is not cleared, so a subsequent call will return -2 and clear the
 flag.
 </p></div>
</section>
</li>
<li>
<section class="detail" id="checkIsActive()">
<h3>checkIsActive</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">checkIsActive</span>()
                      throws <span class="exceptions"><a href="PcapClosedException.html" title="class in org.jnetpcap">PcapClosedException</a></span></div>
<div class="block">Checks if the current Pcap structure is active and open. It automatically
 throws an exception when its closed, but will not crash the VM. All dynamic
 non-native method in Pcap and any subclassed extensions should always make
 this call before attempting to do anything with pcap. The call makes sure
 that the pcap_t structure is still allocated and assigned to this object.
 If Pcap has been closed, no dynamic methods should be allowed to do
 anything. Native methods already perform this check. Static methods do not
 rely on pcap_t structure, since they are static, so they can not do this
 check.</div>
<dl class="notes">
<dt>Throws:</dt>
<dd><code><a href="PcapClosedException.html" title="class in org.jnetpcap">PcapClosedException</a></code> - if pcap_t structure has been deallocated, another words if
           Pcap.close has already been called.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="close()">
<h3>close</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">close</span>()</div>
<div class="block">pcap_close() closes the files associated with p and deallocates resources.</div>
</section>
</li>
<li>
<section class="detail" id="compile(org.jnetpcap.PcapBpfProgram,java.lang.String,int,int)">
<h3>compile</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">compile</span><wbr><span class="parameters">(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;str,
 int&nbsp;optimize,
 int&nbsp;netmask)</span></div>
<div class="block">Compile a packet filter, converting a high level filtering expression in to
 a progra that can be interpreted by the kernel-level filtering engine.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>program</code> - initially empty, but after the method call will contain the
          compiled BPF program</dd>
<dd><code>str</code> - a string containing the textual expression to be compiled</dd>
<dd><code>optimize</code> - 1 means to do optimizations, any other value means no</dd>
<dd><code>netmask</code> - netmask needed to determine the broadcast address</dd>
<dt>Returns:</dt>
<dd>A return of -1 indicates an error in which case <a href="#getErr()"><code>getErr()</code></a>
         may be used to display the error text.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="datalink()">
<h3>datalink</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">datalink</span>()</div>
<div class="block">Returns the link layer of an adapter.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>PCAP link layer number</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.ByteBufferHandler,T)">
<h3 id="dispatch(int,org.jnetpcap.ByteBufferHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block"><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,int,org.jnetpcap.packet.JPacketHandler,T)">
<h3 id="dispatch(int,int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block"><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>id</code> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>number of packet captured</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,int,org.jnetpcap.packet.PcapPacketHandler,T)">
<h3 id="dispatch(int,int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>id</code> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>number of packet captured</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.JBufferHandler,T)">
<h3 id="dispatch(int,org.jnetpcap.JBufferHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block"><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.packet.JPacketHandler,T)">
<h3 id="dispatch(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block"><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>number of packet captured</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.packet.JPacketHandler,T,org.jnetpcap.packet.JScanner)">
<h3 id="dispatch(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)">dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</span></div>
<div class="block"><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dd><code>scanner</code> - user supplied custom packet scanner</dd>
<dt>Returns:</dt>
<dd>number of packet captured</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.PcapDumper)">
<h3>dispatch</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a>&nbsp;dumper)</span></div>
<div class="block">A specialized dispatch method that utilizes a fast native dumper without
 entering java environment. A custom native pcap handler is provided that
 dumps all incoming packets to the dumper without any processing.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>dumper</code> - open pcap dumper to dump all packets to</dd>
<dt>Returns:</dt>
<dd>number of packets processed</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.PcapHandler,T)">
<h3 id="dispatch(int,org.jnetpcap.PcapHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
<div class="block">Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="ByteBufferHandler.html" title="interface in org.jnetpcap"><code>ByteBufferHandler</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,T)">
<h3 id="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)">dispatch</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
<div class="block">Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="ByteBufferHandler.html" title="interface in org.jnetpcap"><code>ByteBufferHandler</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,T,org.jnetpcap.packet.JScanner)">
<h3 id="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)">dispatch</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">dispatch</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">user of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
<div class="block">Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dd><code>scanner</code> - a custom user quick-scanner for parsing headers within the packet</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="ByteBufferHandler.html" title="interface in org.jnetpcap"><code>ByteBufferHandler</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="dumpOpen(java.lang.String)">
<h3>dumpOpen</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a></span>&nbsp;<span class="element-name">dumpOpen</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;fname)</span></div>
<div class="block">Open a file to write packets. The <code>dumpOpen</code> method is called to
 open a "savefile" for writing. The name '-' is a synonym for stdout.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>fname</code> - specifies the name of the file to open; currently the libpcap
          option to open stdout by using "-" as a string, is not supported
          by jNetPcap</dd>
<dt>Returns:</dt>
<dd>a dumper object or null on error; use <code>getErr</code> method to
         retrieve the error message</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="finalize()">
<h3>finalize</h3>
<div class="member-signature"><span class="modifiers">protected</span>&nbsp;<span class="return-type">void</span>&nbsp;<span class="element-name">finalize</span>()</div>
<div class="block">Cleanup before we're GCed. Will close connection to any open interface.
 Does nothing if connection already closed.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a></code>&nbsp;in class&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getErr()">
<h3>getErr</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">getErr</span>()</div>
<div class="block">return the error text pertaining to the last pcap library error.
 <p>
 Note: the pointer Return will no longer point to a valid error message
 string after the pcap_t passed to it is closed; you must use or copy the
 string before closing the pcap_t.
 </p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the error text pertaining to the last pcap library error</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getNonBlock(java.lang.StringBuilder)">
<h3>getNonBlock</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">getNonBlock</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">pcap_getnonblock() returns the current ``non-blocking'' state of the
 capture descriptor; it always returns 0 on ``savefiles''. If there is an
 error, -1 is returned and errbuf is filled in with an appropriate error
 message.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>errbuf</code> - error buffer where error message will be stored on error</dd>
<dt>Returns:</dt>
<dd>if there is an error, -1 is returned and errbuf is filled in with
         an appropriate error message</dd>
<dt>Since:</dt>
<dd>1.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#setNonBlock(int,java.lang.StringBuilder)"><code>setNonBlock(int, StringBuilder)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="inject(byte[])">
<h3>inject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">inject</span><wbr><span class="parameters">(byte[]&nbsp;buf)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers)</dd>
<dt>Returns:</dt>
<dd>0 number of bytes written otherwise -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="inject(byte[],int,int)">
<h3>inject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">inject</span><wbr><span class="parameters">(byte[]&nbsp;buf,
 int&nbsp;offset,
 int&nbsp;length)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers)</dd>
<dd><code>offset</code> - offset of the first index into the byte array</dd>
<dd><code>length</code> - amount of data to write from the offset</dd>
<dt>Returns:</dt>
<dd>0 number of bytes written otherwise -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="inject(java.nio.ByteBuffer)">
<h3>inject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">inject</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buf)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer</dd>
<dt>Returns:</dt>
<dd>0 number of bytes written otherwise -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="inject(org.jnetpcap.nio.JBuffer,int,int)">
<h3>inject</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">inject</span><wbr><span class="parameters">(<a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buf,
 int&nbsp;start,
 int&nbsp;len)</span></div>
<div class="block">Private method to perform work. The arguments are guarranteed to work with
 buf since we're using a delagate method.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - buffer contains raw data to send</dd>
<dd><code>start</code> - offset into the buffer</dd>
<dd><code>len</code> - number of bytes to send</dd>
<dt>Returns:</dt>
<dd>0 number of bytes written otherwise -1 on failure</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isSwapped()">
<h3>isSwapped</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">isSwapped</span>()</div>
<div class="block">returns true if the current savefile uses a different byte order than the
 current system.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>0 is false, non-zero is true</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.ByteBufferHandler,T)">
<h3 id="loop(int,org.jnetpcap.ByteBufferHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,int,org.jnetpcap.packet.JPacketHandler,T)">
<h3 id="loop(int,int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>id</code> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,int,org.jnetpcap.packet.PcapPacketHandler,T)">
<h3 id="loop(int,int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 int&nbsp;id,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>id</code> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.JBufferHandler,T)">
<h3 id="loop(int,org.jnetpcap.JBufferHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.packet.JPacketHandler,T)">
<h3 id="loop(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.packet.JPacketHandler,T,org.jnetpcap.packet.JScanner)">
<h3 id="loop(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dd><code>scanner</code> - user supplied custom packet scanner</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.PcapDumper)">
<h3>loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="PcapDumper.html" title="class in org.jnetpcap">PcapDumper</a>&nbsp;dumper)</span></div>
<div class="block">A specialized loop method that utilizes a fast native dumper without
 entering java environment. A custom native pcap handler is provided that
 dumps all incoming packets to the dumper without any processing.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>dumper</code> - open pcap dumper to dump all packets to</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.PcapHandler,T)">
<h3 id="loop(int,org.jnetpcap.PcapHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapHandler has been replaced with ByteBufferHandler</div>
</div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - handler's user object type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to read</dd>
<dd><code>handler</code> - called when packet arrives for each packet</dd>
<dd><code>user</code> - opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="ByteBufferHandler.html" title="interface in org.jnetpcap"><code>ByteBufferHandler</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.packet.PcapPacketHandler,T)">
<h3 id="loop(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="loop(int,org.jnetpcap.packet.PcapPacketHandler,T,org.jnetpcap.packet.JScanner)">
<h3 id="loop(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)">loop</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;T&gt;</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">loop</span><wbr><span class="parameters">(int&nbsp;cnt,
 <a href="packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</a>&lt;T&gt;&nbsp;handler,
 T&nbsp;user,
 <a href="packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</a>&nbsp;scanner)</span></div>
<div class="block">Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value <span class="invalid-tag">invalid input: '&lt;'</span> 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p></div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>T</code> - user data type</dd>
<dt>Parameters:</dt>
<dd><code>cnt</code> - number of packets to process</dd>
<dd><code>handler</code> - user supplied packet handler</dd>
<dd><code>user</code> - a custom opaque user object</dd>
<dd><code>scanner</code> - user supplied custom packet scanner</dd>
<dt>Returns:</dt>
<dd>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="majorVersion()">
<h3>majorVersion</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">majorVersion</span>()</div>
<div class="block">Return the major version number of the pcap library used to write the
 savefile.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>return the major version number of the pcap library used to write
         the savefile</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="minorVersion()">
<h3>minorVersion</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">minorVersion</span>()</div>
<div class="block">Return the minor version number of the pcap library used to write the
 savefile.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>return the minor version number of the pcap library used to write
         the savefile</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="next(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>next</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a></span>&nbsp;<span class="element-name">next</span><wbr><span class="parameters">(<a href="PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;pkt_header,
 <a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Return the next available packet. pcap_next() reads the next packet (by
 calling pcap_dispatch() with a cnt of 1) and returns a u_char pointer to
 the data in that packet. (The pcap_pkthdr struct for that packet is not
 supplied.) NULL is returned if an error occured, or if no packets were read
 from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read), or if no more
 packets are available in a ``savefile.'' Unfortunately, there is no way to
 determine whether an error occured or not.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pkt_header</code> - a packet header that will be initialized to corresponding C
          structure captured values</dd>
<dd><code>buffer</code> - a buffer that will be peered with returned buffer from libpcap</dd>
<dt>Returns:</dt>
<dd>buffer containing packet data or null if error occured</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="next(org.jnetpcap.PcapPktHdr)">
<h3>next</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a></span>&nbsp;<span class="element-name">next</span><wbr><span class="parameters">(<a href="PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</a>&nbsp;pkt_header)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use of PcapPktHdr has been replaced with PcapHeader</div>
</div>
<div class="block">Return the next available packet. pcap_next() reads the next packet (by
 calling pcap_dispatch() with a cnt of 1) and returns a u_char pointer to
 the data in that packet. (The pcap_pkthdr struct for that packet is not
 supplied.) NULL is returned if an error occured, or if no packets were read
 from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read), or if no more
 packets are available in a ``savefile.'' Unfortunately, there is no way to
 determine whether an error occured or not.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pkt_header</code> - a packet header that will be initialized to corresponding C
          structure captured values</dd>
<dt>Returns:</dt>
<dd>buffer containing packet data or null if error occured</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="PcapHeader.html" title="class in org.jnetpcap"><code>PcapHeader</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nextEx(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>nextEx</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nextEx</span><wbr><span class="parameters">(<a href="PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;pkt_header,
 <a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. pcap_next_ex fills the pkt_header
 and pkt_data parameters (see pcap_handler()) with the pointers to the
 header and to the data of the next captured packet. </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pkt_header</code> - a packet header that will be initialized to corresponding C
          structure captured values</dd>
<dd><code>buffer</code> - buffer containing packet data or null if error occured</dd>
<dt>Returns:</dt>
<dd>the status code
         <ul>
         <li>1 if the packet has been read without problems
         <li>0 if the timeout set with pcap_open_live() has elapsed. In this
         case pkt_header and pkt_data don't point to a valid packet
         <li>-1 if an error occurred
         <li>-2 if EOF was reached reading from an offline capture
         </ul></dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nextEx(org.jnetpcap.packet.PcapPacket)">
<h3>nextEx</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nextEx</span><wbr><span class="parameters">(<a href="packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</span></div>
<div class="block"><p>
 Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. The packet that is supplied as
 formal parameter, is used to peer, not copy, with the header and buffer of
 the next packet returned from libpcap. The supplied packet's PcapHeader is
 used to peer with the libpcap provided header and the packet object itself
 is used to peer with the libpcap provided packet buffer.
 </p>
 <p>
 The packet contents will point at libpcap buffer space which is not
 permanent. If packet contents are to be referenced on more permanent basis,
 it will be neccessary to copy the contents to a new packet. Here is a short
 example:
 
 <pre>
 Pcap pcap = ...; // From somewhere
 PcapPacket packet = new PcapPacket(JMemory.POINTER);
 
 while (nextEx(packet) == Pcap.NEXT_EX_OK) {
   PcapPacket copy = new PcapPacket(packet); // Make the copy and new obj
 }
 </pre></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>packet</code> - packet that will be peered with the next libpcap returned packet</dd>
<dt>Returns:</dt>
<dd>the status code
         <ul>
         <li>1 if the packet has been read without problems <li>0 if the
         timeout set with pcap_open_live() has elapsed. In this case
         pkt_header and pkt_data don't point to a valid packet <li>-1 if an
         error occurred <li>-2 if EOF was reached reading from an offline
         capture
         </ul></dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="nextEx(org.jnetpcap.PcapPktHdr,org.jnetpcap.PcapPktBuffer)">
<h3>nextEx</h3>
<div class="member-signature"><span class="annotations"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html" title="class or interface in java.lang" class="external-link">@Deprecated</a>
</span><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">nextEx</span><wbr><span class="parameters">(<a href="PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</a>&nbsp;pkt_header,
 <a href="PcapPktBuffer.html" title="class in org.jnetpcap">PcapPktBuffer</a>&nbsp;buffer)</span></div>
<div class="deprecation-block"><span class="deprecated-label">Deprecated.</span>
<div class="deprecation-comment">use PcapHeader and PcapPktBuffer has been deprecated</div>
</div>
<div class="block">Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. pcap_next_ex fills the pkt_header
 and pkt_data parameters (see pcap_handler()) with the pointers to the
 header and to the data of the next captured packet. </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>pkt_header</code> - a packet header that will be initialized to corresponding C
          structure captured values</dd>
<dd><code>buffer</code> - buffer containing packet data or null if error occured</dd>
<dt>Returns:</dt>
<dd>the status code
         <ul>
         <li>1 if the packet has been read without problems
         <li>0 if the timeout set with pcap_open_live() has elapsed. In this
         case pkt_header and pkt_data don't point to a valid packet
         <li>-1 if an error occurred
         <li>-2 if EOF was reached reading from an offline capture
         </ul></dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="PcapHeader.html" title="class in org.jnetpcap"><code>PcapHeader</code></a></li>
<li><a href="nio/JBuffer.html" title="class in org.jnetpcap.nio"><code>JBuffer</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sendPacket(byte[])">
<h3>sendPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">sendPacket</span><wbr><span class="parameters">(byte[]&nbsp;buf)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers)</dd>
<dt>Returns:</dt>
<dd>0 on success and -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sendPacket(byte[],int,int)">
<h3>sendPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">sendPacket</span><wbr><span class="parameters">(byte[]&nbsp;buf,
 int&nbsp;offset,
 int&nbsp;length)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers)</dd>
<dd><code>offset</code> - offset of the first index into the byte array</dd>
<dd><code>length</code> - amount of data to write from the offset</dd>
<dt>Returns:</dt>
<dd>0 on success and -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sendPacket(java.nio.ByteBuffer)">
<h3>sendPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">sendPacket</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buf)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer</dd>
<dt>Returns:</dt>
<dd>0 on success and -1 on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="sendPacket(org.jnetpcap.nio.JBuffer)">
<h3>sendPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">sendPacket</span><wbr><span class="parameters">(<a href="nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buf)</span></div>
<div class="block">This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buf</code> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer</dd>
<dt>Returns:</dt>
<dd>0 on success and -1 on failure</dd>
<dt>Since:</dt>
<dd>1.2</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setDatalink(int)">
<h3>setDatalink</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">setDatalink</span><wbr><span class="parameters">(int&nbsp;dlt)</span></div>
<div class="block">Set the current data link type of the pcap descriptor to the type specified
 by dlt.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dlt</code> - new dlt</dd>
<dt>Returns:</dt>
<dd>-1 is returned on failure</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setFilter(org.jnetpcap.PcapBpfProgram)">
<h3>setFilter</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">setFilter</span><wbr><span class="parameters">(<a href="PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</a>&nbsp;program)</span></div>
<div class="block">Associate a filter to a capture. pcap_setfilter() is used to specify a
 filter program. fp is a pointer to a bpf_program struct, usually the result
 of a call to pcap_compile(). -1 is returned on failure, in which case
 pcap_geterr() may be used to display the error text; 0 is returned on
 success.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>program</code> - the program</dd>
<dt>Returns:</dt>
<dd>-1 is returned on failure, in which case pcap_geterr() may be used
         to display the error text; 0 is returned on success</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="setNonBlock(int,java.lang.StringBuilder)">
<h3>setNonBlock</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">setNonBlock</span><wbr><span class="parameters">(int&nbsp;nonBlock,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" title="class or interface in java.lang" class="external-link">StringBuilder</a>&nbsp;errbuf)</span></div>
<div class="block">pcap_setnonblock() puts a capture descriptor, opened with pcap_open_live(),
 into ``non-blocking'' mode, or takes it out of ``non-blocking'' mode,
 depending on whether the nonblock argument is non-zero or zero. It has no
 effect on ``savefiles''. If there is an error, -1 is returned and errbuf is
 filled in with an appropriate error message; otherwise, 0 is returned. In
 ``non-blocking'' mode, an attempt to read from the capture descriptor with
 pcap_dispatch() will, if no packets are currently available to be read,
 return 0 immediately rather than blocking waiting for packets to arrive.
 pcap_loop() and pcap_next() will not work in ``non-blocking'' mode.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>nonBlock</code> - a non negative value means to set in non blocking mode</dd>
<dd><code>errbuf</code> - error buffer where error message will be stored on error</dd>
<dt>Returns:</dt>
<dd>if there is an error, -1 is returned and errbuf is filled in with
         an appropriate error message</dd>
<dt>Since:</dt>
<dd>1.2</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="#getNonBlock(java.lang.StringBuilder)"><code>getNonBlock(StringBuilder)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="snapshot()">
<h3>snapshot</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">snapshot</span>()</div>
<div class="block">Return the dimension of the packet portion (in bytes) that is delivered to
 the application. pcap_snapshot() returns the snapshot length specified when
 pcap_open_live was called.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the snapshot length specified when pcap_open_live was called</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#openLive(java.lang.String,int,int,int,java.lang.StringBuilder)"><code>openLive(String, int, int, int, StringBuilder)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="stats(org.jnetpcap.PcapStat)">
<h3>stats</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">stats</span><wbr><span class="parameters">(<a href="PcapStat.html" title="class in org.jnetpcap">PcapStat</a>&nbsp;stats)</span></div>
<div class="block">Returns statistics on the current capture. The method fills in the PcapStat
 structure. The values represent packet statistics from the start of the run
 to the time of the call.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>stats</code> - PcapStat object to fill in</dd>
<dt>Returns:</dt>
<dd>-1 if underlying packet capture doesn't support packet statistics
         or if there is an error; use <code>getErr</code> to retrieve the
         error message</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toString()">
<h3>toString</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">toString</span>()</div>
<div class="block">Prints libVersion that Pcap is based on.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a></code>&nbsp;in class&nbsp;<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></code></dd>
<dt>Returns:</dt>
<dd>libpcap version in use by this pcap object</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
