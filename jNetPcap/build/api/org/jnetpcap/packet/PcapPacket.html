<!DOCTYPE HTML>
<html lang="es">
<head>
<!-- Generated by javadoc (18) on Wed Sep 14 03:01:02 CEST 2022 -->
<title>PcapPacket</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-09-14">
<meta name="description" content="declaration: package: org.jnetpcap.packet, class: PcapPacket">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span><span class="nav-bar-toggle-icon"></span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li><a href="#field-summary">Field</a></li>
<li><a href="#constructor-summary">Constr</a></li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li><a href="#constructor-detail">Constr</a></li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field-summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor-summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor-detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.jnetpcap.packet</a></div>
<h1 title="Class PcapPacket" class="title">Class PcapPacket</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance"><a href="../nio/JMemory.html" title="class in org.jnetpcap.nio">org.jnetpcap.nio.JMemory</a>
<div class="inheritance"><a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">org.jnetpcap.nio.JBuffer</a>
<div class="inheritance"><a href="JPacket.html" title="class in org.jnetpcap.packet">org.jnetpcap.packet.JPacket</a>
<div class="inheritance">org.jnetpcap.packet.PcapPacket</div>
</div>
</div>
</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">PcapPacket</span>
<span class="extends-implements">extends <a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></span></div>
<div class="block">A pcap packet. Fully decoded packet that provides access to protocol headers
 as determined during the decoding process. A <code>PcapPacket</code> class is
 designed to work with pcap library. It can not be used to create a new packet
 from an external memory buffer that only contains packet data, such as
 preparing a packet to be sent from a network interface. You can use
 <code>JMemoryPacket</code> to create an in memory packet from scratch.
 PcapPackets need a PcapHeader which is provided by libpcap at the time the
 packet was captured. Also the PcapPacket contains decoded state information
 which can be used to query the packet for its contents using friendly java
 API and compile-time type-safety. <h2>Packet accessors</h2> Once a decoded
 packet is received, the user can query the packet for its various properties.
 The most important of which is the existance of any particular protocol
 header within the packet data buffer. The data buffer is scanned and decoded.
 Any discovery of a protocol header within, is recorded in packet's state. The
 following accessors can be used to query if a particular header has been
 found within a packet:
 <ul>
 <li> <code>JPacket.hasHeader(int id):boolean</code> - id is the numerical
 protocol ID assigned to each header type by JRegistry. The accessor returns a
 boolean true or false if the header exists within the packet.</li>
 <li>
 <code>JPacket.getHeader(&lt;? extends JHeader&gt; header): &lt;? extends JHeader&gt;</code>
 - an accessor that retrieves a specific instance of a header. A user supplied
 instance of a protocol header is used, initialized to point at the
 appropriate memory location within the data buffer, where the protocol
 header's state and contents reside.</li>
 <li>
 <code>JPacket.hasHeader(<span class="invalid-tag">invalid input: '&lt;'</span>&lt;? extends JHeader&gt; header): boolean</code> -
 a convenience accessor that combines hasHeader and getHeader methods into
 one. If the header is found within the packet, boolean true is returned and
 at the same time the user supplied instance of the header is initialized to
 pointer at the header. Otherwise false is returned.</li>
 </ul>
 <p>
 Here is an example of how to use an accessor form a PcapPacketHandler:
 
 <pre>
 public void nextPacket(PcapPacket packet, Object user) {
        if (packet.hasHeader(Ethernet.ID)) {
                Ethernet eth = packet.getHeader(new Ethernet());
 
                System.out.printf(&quot;ethernet.type=%X\n&quot;, eth.type());
        }
 }
 </pre>
 
 Or more conveniently, combine hasHeader and getHeader in a single call
 
 <pre>
 private Ethernet eth = new Ethernet(); // Preallocate our ethernet header
 
 private Ip4 ip = new Ip4(); // Preallocat IP version 4 header
 
 public void nextPacket(PcapPacket packet, Object user) {
        if (packet.hasHeader(eth)) {
                System.out.printf(&quot;ethernet.type=%X\n&quot;, eth.type());
        }
 
        if (packet.hasHeader(ip)) {
                System.out.println(&quot;ip.version=%d\n&quot;, ip.version());
        }
 }
 </pre>
 
 <h3>Accessing a subheader such as ip options</h3>
 You can also access sub headers, usually supplied as options by the protocol
 during transmission.
 
 <pre>
 private Ip4 ip = new Ip4(); // Preallocat IP version 4 header
 private Ip4.Timestamp timestamp = new Ip4.Timestamp(); // Optional header
 
 public void nextPacket(PcapPacket packet, Object user) {
  if (packet.hasHeader(ip) &amp;&amp; ip.hasSubHeader(timestamp)) {
    System.out.println(&quot;ip.version=%d\n&quot;, ip.version);
    System.out.println(&quot;timestamp optional header length=%d\n&quot;, timstamp.length());
  }
 </pre>
 
 A couple of points about the sub header example. Notice that we preallocated
 a Timestamp header, which is defined from within Ip4 class itself, but is a
 separate class on its own none the less. Next we first check if Ip4 header is
 present at all in the packet, peer it if exists (combined hasHeader and
 getHeader accessor method) and as a second step we check with the Ip4 header
 if it has an optional header using <code>ip.hasSubHeader(timestamp)</code>.
 If the method returns true, it also peers the sub header timestamp with the
 appropriate packet data buffer where the optional header resides.
 <h3>Formatting packet for output</h3>
 A packet can easily be formatted for textual output. Any supported formatter,
 such as TextFormatter or XmlFormatter can be used to format a packet for
 output. Also JPacket.toString() method uses an internal StringBuilder based
 TextFormatter that formats the packet for textual output in a string buffer.
 At this time both ip and timestamp header instances are properly intialized
 and can be used to access their respective headers.
 
 <pre>
 JPacket packet = // From out handler
 TextFormatter out = new TextFormatter(System.out);
 
 out.format(packet); // Send pretty output to stdout
 
 // Or save time
 System.out.println(packet.toString()); // Use internal TextFormatter
 </pre>
 
 </p>
 <h2>Packet's lifecycle</h2> A PcapPacket is made up of 3 parts:
 <ul>
 <li>Packet data buffer - peered with packet object itself</li>
 <li>Packet state - peered with packet state object</li>
 <li>PcapCapture header - peered with packet header object</li>
 </ul>
 <p>
 Each part of the packet is managed independently, that is either part can be
 initialized or not. Either part can point to any memory location, including a
 large single buffer of contigues bytes that contains all 3 parts, header,
 state and packet data. There are various methods supplied by PcapPacket that
 allow an external buffer to be peered with all 3 parts of the packet. There
 are also many methods for transfering (deep copy) the data to and from
 buffers.
 </p>
 <p>
 All of these components are stored in native memory in native C structures
 that are peered with the packet API classes. The classes, managed by
 <code>JMemory</code> class are referencing native memory locations. Any
 native method that is called upon in the PcapPacket class or its base
 classes, will perform those operations on the peered structure and data.
 </p>
 When a packet is delivered from either Pcap.loop or Pcap.dispatch methods,
 the capture header, packet state and packet data all point to different
 unrelated memory locations. That is, capture header is peered with the
 libpcap supplied pcap_pkthdr structure, Packet data buffer (the packet
 itself) is peered with the data buffer supplied by pcap and the packet state
 is peered with its packet_state_t structure as supplied by the JScanner,
 typically out of its internal buffer. None of these default memory locations
 are persistent for very long time. Both libpcap and JScanner buffers are
 round robin buffers that eventually wrap around and reuse previously
 dispatched memory.
 <p>
 These temporary packets are only suitable for immediate use. That is if the
 packets are processed immediately when received and then discarded, they do
 not need to be preserved. If a packet is to be put on a queue and for later
 processing, the packet needs to preserve its state. That requires a physical
 copy of all 3 components of the packet to a new memory location. The most
 efficient way to store the new packet is to allocate a memory buffer large
 enough to hold all of the packets state and data out of a JMemoryPool. The
 JPacket provides a default singleton memory pool out of which all packets
 allocate memory out of for the required space.
 </p>
 <h2>Advanced topiccs</h2> Below are several sections that describe the
 lifecycle of a packet in more depth. For simply usage, the termporary packets
 can be used immediately in the handler and then the packets can be discarded.
 For more advanced usage lets go into the detail of how packet data can be
 copied, preserved and peered to one another. <h3>Perserving packet's state
 and data</h3> In order to preserve packet's state and data a deep copy needs
 to be performed of all 3 components of he packet. PcapPacket class provides
 several <code>PcapPacket.transferTo</code> methods that perform deep copies
 of the packet. For efficiency reasons, each transferTo method are designed to
 copy data into a memory buffer of larger size. The packet state and data are
 copied to the buffer with the following layout within the buffer:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 <p>
 The buffer to which this copy takes place can be an external buffer or an
 internally allocated one by the packet class itself. As stated before,
 packet's use an interal singleton memory pool to allocate memory out of more
 efficiently. This memory allocates large native memory blocks which are then
 sub divided further and given out by the memory pool on a per request basis.
 All the copies are done natively by low level native copy routines, not in
 java space for maximum performace.
 </p>
 <p>
 The easiest way to copy packet contents as received, for example, from
 <code>PcapPacketHandler</code>, is to pass the temporary packet to the
 PcapPacket constructor which will automatically allocate new space for the
 packet state and data and perform a deep copy. The new packet immediately
 becomes usable and is permanently stored in memory with its state and data,
 until garbage collected. Here is an example of a PcapPacketHandler that
 copies the temporary packet to new permanent one:
 
 <pre>
 pulic void nextPacket(PcapPacket packet, Queue&lt;PcapPacket&gt; queue) {
   PcapPacket permanent = new PcapPacket(packet);  
   queue.offer(permanent); 
 }
 </pre>
 
 </p>
 <p>
 </p>
 <p>
 Alternative is to reused another packet and transfer the temporary packets
 state and data to it or create a new unitiatialized packet with
 <code>new PcapPacket(JMemory.Type.POINTER)</code> constructor and
 subsequently perform <code>PcapPacket.transferTo(PcapPacket)</code> call to
 copy the contents. In the first case where an existing packet is being
 reused, if that packet already contains a large enough memory buffer to hold
 the state and data of the temporary packet, that buffer is reused. Otherwise
 a new buffer is allocated out of the default memory pool. Here is an exmaple:
 *
 
 <pre>
 
 final PcapPacket permanent = new PcapPacket(Type.POINTER);
 
 pulic void nextPacket(PcapPacket packet, Queue&lt;PcapPacket&gt; queue) {
   permanent.transferStateAndData(packet); 
   // Or
   packet.transferTo(permanent);
 }
 </pre>
 
 In either case, any existing buffer previously allocated in the permanent
 packet if its big enough to hold the state and data of the packet, is reused,
 saving time on memory allocation. You can also manually allocate a large
 buffer and reuse a packet:
 
 <pre>
 
 final PcapPacket permanent = new PcapPacket(64 * 1024); // Preallocate 64K
 
 pulic void nextPacket(PcapPacket packet, Queue&lt;PcapPacket&gt; queue) {
   permanent.transferStateAndData(packet); 
   // Or
   packet.transferTo(permanent);
 }
 </pre>
 
 In this example, the packet buffer will always be large enough and resused.
 But still this is a semi permanentn state.
 </p>
 <p>
 Yet another alternative is to store the contents of the packet in an external
 buffer such as ByteBuffer, JBuffer or simply a byte[] and then at an
 appropriate time, transfer the data back or peer the external buffer with a
 packet object. Only the byte[] buffer type and ByteBuffer backed by a byte
 array, can not be peered directly with a packet as only buffer sources that
 are native memory based can be peered. All external buffer types can be
 copied back into a packet, if peering is not required. New memory space is
 allocated for the copy. Here is an example:
 
 <pre>
 pulic void nextPacket(PcapPacket packet, Queue&lt;PcapPacket&gt; queue) {
   JBuffer jbuf = new JBuffer(packet.getTotalSize());
   packet.transferTo(jbuf);
   // Or
   ByteBuffer bbuf = ByteBuffer.allocateDirect(packet.getTotalSize());
   packet.transferTo(bbuf);
   // Or
   byte[] babuf = new byte[packet.getTotalSize())];
   packet.transferTo(babuf);
 }
 </pre>
 
 In all 3 cases, complete the packet's state and data buffer are copied to
 external buffer.
 </p>
 <h2>Initializing packet from an external buffer</h2> Packet state and data
 can be preseved in an external buffer large enough to hold the entire packet
 with its state. PcapPacket class provides transferStateAndData and peer
 methods that allow the external packet data to be either copied into a packet
 or the packet be peered directly with the external buffer. Peering does not
 need to allocate memory to hold the packet state, but its state and data are
 directly read out of the extern buffer. If you change the contents of the
 external buffer, the packet's state and data will change as well. Care must
 be take with a direct reference to an external buffer, as its easy to
 override sensitive data causing the packet to behave wildly and unexpectidly.
 <code>JMemory</code> class prevents buffer overrun attacks and any access to
 memory that has not been allocated. a direct reference. Here is an example:
 
 <pre>
 pulic void nextPacket(PcapPacket packet, Queue&lt;PcapPacket&gt; queue) {
   JBuffer jbuf = new JBuffer(packet.getTotalSize());
   packet.transferTo(jbuf);
   // Or
   ByteBuffer bbuf = ByteBuffer.allocateDirect(packet.getTotalSize());
   packet.transferTo(bbuf);
   // Or
   byte[] babuf = new byte[packet.getTotalSize())];
   packet.transferTo(babuf);
   
   PcapPacket p1 = new PcapPacket(jbuf); // Deep copy
   
   PcapPacket p2 = new PcapPacket(Type.POINTER); // Uninitialized
   bbuf.flip(); // Have to flip the buffer to access the just written contents
   p2.peer(bbuf); // No copies, peered directly with external buffer
   
   PcapPacket p3 = new PcapPacket(Type.POINTER); // Uninitialized
   p3.transferStateAndData(babuf); // Deep copy - byte[] buffers can not be peered
   
   PcapPacket p4 = new PcapPacket(Type.POINTER); // Uninitialized
   p4.peer(p3); // both point at same internal memory space
 }
 </pre>
 
 The above example demonstrates 3 different ways that data from an external
 buffer can be either copied or peered with a new packet object. In all cases
 the data and state were transfered from the temporary packet received by the
 handler to a more permenant buffer and then packet. An interesting scenerio
 occures with packet p4. Lets take a closer look.
 <p>
 First, p3 is created unitialized, meaning that packet header, state and data
 are null pointers at this time, they don't point to anything and any accessor
 method used will immediately throw a NullPointerException. Second, the byte[]
 external buffer is copied into newly allocate memory space by p3. The packet
 is intiailized to pointer at its internal buffer for the header, state and
 packet data. Then we create p4, also unitialized and in the following step we
 peer p4 to p3. That is p4 points at the exact same memory location for
 packet's header, state and data. No new memory was allocated and changing the
 contents in either packet, p3 or p4, will have immediate effect on the other
 packet. Another words, both p3 and p4 are peered to the same internal memory
 space.
 </p></div>
<dl class="notes">
<dt>Author:</dt>
<dd>Mark Bednarczyk, Sly Technologies, Inc.</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../nio/JMemoryPool.html" title="class in org.jnetpcap.nio"><code>JMemoryPool</code></a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested-classes-inherited-from-class-org.jnetpcap.packet.JPacket">Nested classes/interfaces inherited from class&nbsp;org.jnetpcap.packet.<a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></h2>
<code><a href="JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</a></code></div>
<div class="inherited-list">
<h2 id="nested-classes-inherited-from-class-org.jnetpcap.nio.JMemory">Nested classes/interfaces inherited from class&nbsp;org.jnetpcap.nio.<a href="../nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</a></h2>
<code><a href="../nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</a></code></div>
</section>
</li>
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field-summary">
<h2>Field Summary</h2>
<div class="inherited-list">
<h3 id="fields-inherited-from-class-org.jnetpcap.packet.JPacket">Fields inherited from class&nbsp;org.jnetpcap.packet.<a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></h3>
<code><a href="JPacket.html#DEFAULT_STATE_HEADER_COUNT">DEFAULT_STATE_HEADER_COUNT</a>, <a href="JPacket.html#defaultScanner">defaultScanner</a>, <a href="JPacket.html#memory">memory</a>, <a href="JPacket.html#pool">pool</a>, <a href="JPacket.html#state">state</a></code></div>
<div class="inherited-list">
<h3 id="fields-inherited-from-class-org.jnetpcap.nio.JMemory">Fields inherited from class&nbsp;org.jnetpcap.nio.<a href="../nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</a></h3>
<code><a href="../nio/JMemory.html#JNETPCAP_LIBRARY_NAME">JNETPCAP_LIBRARY_NAME</a>, <a href="../nio/JMemory.html#MAX_DIRECT_MEMORY_DEFAULT">MAX_DIRECT_MEMORY_DEFAULT</a>, <a href="../nio/JMemory.html#POINTER">POINTER</a></code></div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li>
<section class="constructor-summary" id="constructor-summary">
<h2>Constructor Summary</h2>
<div class="caption"><span>Constructors</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Constructor</div>
<div class="table-header col-last">Description</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(byte%5B%5D)" class="member-name-link">PcapPacket</a><wbr>(byte[]&nbsp;buffer)</code></div>
<div class="col-last even-row-color">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(int)" class="member-name-link">PcapPacket</a><wbr>(int&nbsp;size)</code></div>
<div class="col-last odd-row-color">
<div class="block">Allocates a memory buffer large enough to hold atleast size bytes of data
 and the decoded packet state.</div>
</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(int,int)" class="member-name-link">PcapPacket</a><wbr>(int&nbsp;size,
 int&nbsp;headerCount)</code></div>
<div class="col-last even-row-color">
<div class="block">Allocates memory for packet data and certain amount of state and headers.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(java.nio.ByteBuffer)" class="member-name-link">PcapPacket</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.nio.JBuffer)" class="member-name-link">PcapPacket</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.nio.JMemory.Type)" class="member-name-link">PcapPacket</a><wbr>(<a href="../nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</a>&nbsp;type)</code></div>
<div class="col-last odd-row-color">
<div class="block">Special type of instantiation that allows an empty packet to be peered, or
 in C terms its a packet pointer with no actual memory allocated.</div>
</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.packet.JPacket)" class="member-name-link">PcapPacket</a><wbr>(<a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a>&nbsp;src)</code></div>
<div class="col-last even-row-color">
<div class="block">Does a deep copy of the source packet into newly allocated native memory
 location.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.packet.PcapPacket)" class="member-name-link">PcapPacket</a><wbr>(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;src)</code></div>
<div class="col-last odd-row-color">
<div class="block">Does a deep copy of the source packet into newly allocated native memory
 location.</div>
</div>
<div class="col-constructor-name even-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)" class="member-name-link">PcapPacket</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color">
<div class="block">Allocates memory for new packet and copies both the header and packet
 buffer to newly allocated memory.</div>
</div>
<div class="col-constructor-name odd-row-color"><code><a href="#%3Cinit%3E(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">PcapPacket</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color">
<div class="block">Allocates memory for new packet and copies both the header and packet
 buffer to newly allocated memory.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getCaptureHeader()" class="member-name-link">getCaptureHeader</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Retrieves the PcapHeader, capture header provided by libpcap.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getTotalSize()" class="member-name-link">getTotalSize</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Gets the total size of the packet including pcap header, decoded state and
 data buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peer(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">peer</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerAndScan(int,org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">peerAndScan</a><wbr>(int&nbsp;dlt,
 <a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peer and scan.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerHeaderAndData(org.jnetpcap.nio.JBuffer)" class="member-name-link">peerHeaderAndData</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peers both header and data to buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerHeaderAndData(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)" class="member-name-link">peerHeaderAndData</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peer header and data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerHeaderAndData(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">peerHeaderAndData</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peer header and data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerStateAndData(java.nio.ByteBuffer)" class="member-name-link">peerStateAndData</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peers the contents of the buffer directly with this packet.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#peerStateAndData(org.jnetpcap.nio.JBuffer)" class="member-name-link">peerStateAndData</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Peers the contents of the buffer directly with this packet.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferHeaderAndDataFrom(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)" class="member-name-link">transferHeaderAndDataFrom</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of header and packet buffer to a single newly allocated
 buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferHeaderAndDataFrom(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)" class="member-name-link">transferHeaderAndDataFrom</a><wbr>(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of header and packet buffer to a single newly allocated
 buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataFrom(byte%5B%5D)" class="member-name-link">transferStateAndDataFrom</a><wbr>(byte[]&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataFrom(java.nio.ByteBuffer)" class="member-name-link">transferStateAndDataFrom</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataFrom(org.jnetpcap.nio.JBuffer)" class="member-name-link">transferStateAndDataFrom</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of the buffer to new packet.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataFrom(org.jnetpcap.packet.PcapPacket)" class="member-name-link">transferStateAndDataFrom</a><wbr>(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Deep copy of the supplied packet to this packet.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataTo(byte%5B%5D)" class="member-name-link">transferStateAndDataTo</a><wbr>(byte[]&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of this packet to buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataTo(java.nio.ByteBuffer)" class="member-name-link">transferStateAndDataTo</a><wbr>(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of this packet to buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataTo(org.jnetpcap.nio.JBuffer)" class="member-name-link">transferStateAndDataTo</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of this packet to buffer.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataTo(org.jnetpcap.nio.JBuffer,int)" class="member-name-link">transferStateAndDataTo</a><wbr>(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer,
 int&nbsp;offset)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Copies contents of this packet to buffer.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#transferStateAndDataTo(org.jnetpcap.packet.PcapPacket)" class="member-name-link">transferStateAndDataTo</a><wbr>(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Deep copy of the this packet to the supplied packet.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-org.jnetpcap.packet.JPacket">Methods inherited from class&nbsp;org.jnetpcap.packet.<a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></h3>
<code><a href="JPacket.html#allocate(int)">allocate</a>, <a href="JPacket.html#getAllocatedMemorySize()">getAllocatedMemorySize</a>, <a href="JPacket.html#getDefaultScanner()">getDefaultScanner</a>, <a href="JPacket.html#getFormatter()">getFormatter</a>, <a href="JPacket.html#getFrameNumber()">getFrameNumber</a>, <a href="JPacket.html#getHeader(T)">getHeader</a>, <a href="JPacket.html#getHeader(T,int)">getHeader</a>, <a href="JPacket.html#getHeaderByIndex(int,T)">getHeaderByIndex</a>, <a href="JPacket.html#getHeaderCount()">getHeaderCount</a>, <a href="JPacket.html#getHeaderIdByIndex(int)">getHeaderIdByIndex</a>, <a href="JPacket.html#getHeaderInstanceCount(int)">getHeaderInstanceCount</a>, <a href="JPacket.html#getMemoryBuffer(byte%5B%5D)">getMemoryBuffer</a>, <a href="JPacket.html#getMemoryBuffer(int)">getMemoryBuffer</a>, <a href="JPacket.html#getMemoryBuffer(java.nio.ByteBuffer)">getMemoryBuffer</a>, <a href="JPacket.html#getMemoryBuffer(org.jnetpcap.nio.JBuffer)">getMemoryBuffer</a>, <a href="JPacket.html#getMemoryPool()">getMemoryPool</a>, <a href="JPacket.html#getPacketWirelen()">getPacketWirelen</a>, <a href="JPacket.html#getScanner()">getScanner</a>, <a href="JPacket.html#getState()">getState</a>, <a href="JPacket.html#hasHeader(int)">hasHeader</a>, <a href="JPacket.html#hasHeader(int,int)">hasHeader</a>, <a href="JPacket.html#hasHeader(T)">hasHeader</a>, <a href="JPacket.html#hasHeader(T,int)">hasHeader</a>, <a href="JPacket.html#remaining(int)">remaining</a>, <a href="JPacket.html#remaining(int,int)">remaining</a>, <a href="JPacket.html#scan(int)">scan</a>, <a href="JPacket.html#setFormatter(org.jnetpcap.packet.format.JFormatter)">setFormatter</a>, <a href="JPacket.html#setMemoryPool(org.jnetpcap.nio.JMemoryPool)">setMemoryPool</a>, <a href="JPacket.html#shutdown()">shutdown</a>, <a href="JPacket.html#toHexdump()">toHexdump</a>, <a href="JPacket.html#toString()">toString</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-org.jnetpcap.nio.JBuffer">Methods inherited from class&nbsp;org.jnetpcap.nio.<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a></h3>
<code><a href="../nio/JBuffer.html#findUTF8String(int,char...)">findUTF8String</a>, <a href="../nio/JBuffer.html#getByte(int)">getByte</a>, <a href="../nio/JBuffer.html#getByteArray(int,byte%5B%5D)">getByteArray</a>, <a href="../nio/JBuffer.html#getByteArray(int,byte%5B%5D,int,int)">getByteArray</a>, <a href="../nio/JBuffer.html#getByteArray(int,int)">getByteArray</a>, <a href="../nio/JBuffer.html#getDouble(int)">getDouble</a>, <a href="../nio/JBuffer.html#getFloat(int)">getFloat</a>, <a href="../nio/JBuffer.html#getInt(int)">getInt</a>, <a href="../nio/JBuffer.html#getLong(int)">getLong</a>, <a href="../nio/JBuffer.html#getShort(int)">getShort</a>, <a href="../nio/JBuffer.html#getUByte(int)">getUByte</a>, <a href="../nio/JBuffer.html#getUInt(int)">getUInt</a>, <a href="../nio/JBuffer.html#getUShort(int)">getUShort</a>, <a href="../nio/JBuffer.html#getUTF8Char(int)">getUTF8Char</a>, <a href="../nio/JBuffer.html#getUTF8String(int,char...)">getUTF8String</a>, <a href="../nio/JBuffer.html#getUTF8String(int,int)">getUTF8String</a>, <a href="../nio/JBuffer.html#getUTF8String(int,java.lang.StringBuilder,char...)">getUTF8String</a>, <a href="../nio/JBuffer.html#getUTF8String(int,java.lang.StringBuilder,int)">getUTF8String</a>, <a href="../nio/JBuffer.html#isReadonly()">isReadonly</a>, <a href="../nio/JBuffer.html#order()">order</a>, <a href="../nio/JBuffer.html#order(java.nio.ByteOrder)">order</a>, <a href="../nio/JBuffer.html#peer(java.nio.ByteBuffer)">peer</a>, <a href="../nio/JBuffer.html#peer(org.jnetpcap.nio.JBuffer)">peer</a>, <a href="../nio/JBuffer.html#peer(org.jnetpcap.nio.JBuffer,int,int)">peer</a>, <a href="../nio/JBuffer.html#peer(org.jnetpcap.nio.JMemory)">peer</a>, <a href="../nio/JBuffer.html#setByte(int,byte)">setByte</a>, <a href="../nio/JBuffer.html#setByteArray(int,byte%5B%5D)">setByteArray</a>, <a href="../nio/JBuffer.html#setByteBuffer(int,java.nio.ByteBuffer)">setByteBuffer</a>, <a href="../nio/JBuffer.html#setDouble(int,double)">setDouble</a>, <a href="../nio/JBuffer.html#setFloat(int,float)">setFloat</a>, <a href="../nio/JBuffer.html#setInt(int,int)">setInt</a>, <a href="../nio/JBuffer.html#setLong(int,long)">setLong</a>, <a href="../nio/JBuffer.html#setShort(int,short)">setShort</a>, <a href="../nio/JBuffer.html#setShort0(long,boolean,int,short)">setShort0</a>, <a href="../nio/JBuffer.html#setUByte(int,int)">setUByte</a>, <a href="../nio/JBuffer.html#setUInt(int,long)">setUInt</a>, <a href="../nio/JBuffer.html#setUShort(int,int)">setUShort</a>, <a href="../nio/JBuffer.html#transferFrom(byte%5B%5D)">transferFrom</a>, <a href="../nio/JBuffer.html#transferFrom(java.nio.ByteBuffer,int)">transferFrom</a>, <a href="../nio/JBuffer.html#transferFrom(org.jnetpcap.nio.JBuffer)">transferFrom</a>, <a href="../nio/JBuffer.html#transferTo(java.nio.ByteBuffer,int,int)">transferTo</a>, <a href="../nio/JBuffer.html#transferTo(org.jnetpcap.nio.JBuffer)">transferTo</a>, <a href="../nio/JBuffer.html#transferTo(org.jnetpcap.nio.JBuffer,int,int,int)">transferTo</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-org.jnetpcap.nio.JMemory">Methods inherited from class&nbsp;org.jnetpcap.nio.<a href="../nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</a></h3>
<code><a href="../nio/JMemory.html#availableDirectMemory()">availableDirectMemory</a>, <a href="../nio/JMemory.html#check()">check</a>, <a href="../nio/JMemory.html#cleanup()">cleanup</a>, <a href="../nio/JMemory.html#createReference(long,long)">createReference</a>, <a href="../nio/JMemory.html#isInitialized()">isInitialized</a>, <a href="../nio/JMemory.html#isJMemoryBasedOwner()">isJMemoryBasedOwner</a>, <a href="../nio/JMemory.html#isOwner()">isOwner</a>, <a href="../nio/JMemory.html#maxDirectMemory()">maxDirectMemory</a>, <a href="../nio/JMemory.html#peer(org.jnetpcap.nio.JMemory,int,int)">peer</a>, <a href="../nio/JMemory.html#reservedDirectMemory()">reservedDirectMemory</a>, <a href="../nio/JMemory.html#setSize(int)">setSize</a>, <a href="../nio/JMemory.html#size()">size</a>, <a href="../nio/JMemory.html#softDirectMemory()">softDirectMemory</a>, <a href="../nio/JMemory.html#toDebugString()">toDebugString</a>, <a href="../nio/JMemory.html#toHexdump(int,boolean,boolean,boolean)">toHexdump</a>, <a href="../nio/JMemory.html#totalActiveAllocated()">totalActiveAllocated</a>, <a href="../nio/JMemory.html#totalAllocateCalls()">totalAllocateCalls</a>, <a href="../nio/JMemory.html#totalAllocated()">totalAllocated</a>, <a href="../nio/JMemory.html#totalAllocatedSegments0To255Bytes()">totalAllocatedSegments0To255Bytes</a>, <a href="../nio/JMemory.html#totalAllocatedSegments256OrAbove()">totalAllocatedSegments256OrAbove</a>, <a href="../nio/JMemory.html#totalDeAllocateCalls()">totalDeAllocateCalls</a>, <a href="../nio/JMemory.html#totalDeAllocated()">totalDeAllocated</a>, <a href="../nio/JMemory.html#transferFrom(byte%5B%5D,int,int,int)">transferFrom</a>, <a href="../nio/JMemory.html#transferFrom(java.nio.ByteBuffer)">transferFrom</a>, <a href="../nio/JMemory.html#transferFromDirect(java.nio.ByteBuffer,int)">transferFromDirect</a>, <a href="../nio/JMemory.html#transferOwnership(org.jnetpcap.nio.JMemory)">transferOwnership</a>, <a href="../nio/JMemory.html#transferTo(byte%5B%5D)">transferTo</a>, <a href="../nio/JMemory.html#transferTo(byte%5B%5D,int,int,int)">transferTo</a>, <a href="../nio/JMemory.html#transferTo(java.nio.ByteBuffer)">transferTo</a>, <a href="../nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory)">transferTo</a>, <a href="../nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory,int,int,int)">transferTo</a>, <a href="../nio/JMemory.html#transferTo0(long,byte%5B%5D,int,int,int)">transferTo0</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li>
<section class="constructor-details" id="constructor-detail">
<h2>Constructor Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="&lt;init&gt;(byte[])">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(byte[]&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(java.nio.ByteBuffer)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(int)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(int&nbsp;size)</span></div>
<div class="block">Allocates a memory buffer large enough to hold atleast size bytes of data
 and the decoded packet state. The size of the the state structure is
 estimated to contain maximum of DEFAULT_STATE_HEADER_COUNT
 headers.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>size</code> - amount of memory to allocate to hold packet data</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(int,int)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(int&nbsp;size,
 int&nbsp;headerCount)</span></div>
<div class="block">Allocates memory for packet data and certain amount of state and headers.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>size</code> - number of bytes for packet data</dd>
<dd><code>headerCount</code> - maximum number of header to allocate space for</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.nio.JBuffer)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.packet.JPacket)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a>&nbsp;src)</span></div>
<div class="block">Does a deep copy of the source packet into newly allocated native memory
 location.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - source packet</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Allocates memory for new packet and copies both the header and packet
 buffer to newly allocated memory. Packet state is uninitialized and needs
 to be decoded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - capture header</dd>
<dd><code>buffer</code> - packet data buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Allocates memory for new packet and copies both the header and packet
 buffer to newly allocated memory. Packet state is uninitialized and needs
 to be decoded.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - capture header</dd>
<dd><code>buffer</code> - packet data buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.packet.PcapPacket)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;src)</span></div>
<div class="block">Does a deep copy of the source packet into newly allocated native memory
 location.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - source packet</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="&lt;init&gt;(org.jnetpcap.nio.JMemory.Type)">
<h3>PcapPacket</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="element-name">PcapPacket</span><wbr><span class="parameters">(<a href="../nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</a>&nbsp;type)</span></div>
<div class="block">Special type of instantiation that allows an empty packet to be peered, or
 in C terms its a packet pointer with no actual memory allocated. Accessing
 most methods in this packet object before its initialized will throw
 NullPointerException as the object has not been initialized yet.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>type</code> - state of the object to create</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="getCaptureHeader()">
<h3>getCaptureHeader</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a></span>&nbsp;<span class="element-name">getCaptureHeader</span>()</div>
<div class="block">Retrieves the PcapHeader, capture header provided by libpcap.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="JPacket.html#getCaptureHeader()">getCaptureHeader</a></code>&nbsp;in class&nbsp;<code><a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></code></dd>
<dt>Returns:</dt>
<dd>capture header</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getTotalSize()">
<h3>getTotalSize</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">getTotalSize</span>()</div>
<div class="block">Gets the total size of the packet including pcap header, decoded state and
 data buffer.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="JPacket.html#getTotalSize()">getTotalSize</a></code>&nbsp;in class&nbsp;<code><a href="JPacket.html" title="class in org.jnetpcap.packet">JPacket</a></code></dd>
<dt>Returns:</dt>
<dd>total size of the packet in bytes</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerHeaderAndData(org.jnetpcap.nio.JBuffer)">
<h3>peerHeaderAndData</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerHeaderAndData</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Peers both header and data to buffer. The buffer must contain first header
 then packet data layout in its memory. Packet state is uninitialized.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes peered</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peer(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>peer</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peer</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Peer.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - the header</dd>
<dd><code>buffer</code> - the buffer</dd>
<dt>Returns:</dt>
<dd>the int</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerAndScan(int,org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>peerAndScan</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerAndScan</span><wbr><span class="parameters">(int&nbsp;dlt,
 <a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Peer and scan.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>dlt</code> - the dlt</dd>
<dd><code>header</code> - the header</dd>
<dd><code>buffer</code> - the buffer</dd>
<dt>Returns:</dt>
<dd>the int</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerHeaderAndData(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)">
<h3>peerHeaderAndData</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerHeaderAndData</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span>
                      throws <span class="exceptions"><a href="PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</a></span></div>
<div class="block">Peer header and data.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - the header</dd>
<dd><code>buffer</code> - the buffer</dd>
<dt>Returns:</dt>
<dd>the int</dd>
<dt>Throws:</dt>
<dd><code><a href="PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</a></code> - the peering exception</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerHeaderAndData(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>peerHeaderAndData</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerHeaderAndData</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Peer header and data.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - the header</dd>
<dd><code>buffer</code> - the buffer</dd>
<dt>Returns:</dt>
<dd>the int</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerStateAndData(java.nio.ByteBuffer)">
<h3>peerStateAndData</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerStateAndData</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span>
                     throws <span class="exceptions"><a href="PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</a></span></div>
<div class="block">Peers the contents of the buffer directly with this packet. No copies are
 performed but the capture header, packet state and data are expected to be
 contained within the buffer with a certain layout as described below:
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - Buffer containing packet header, state and data. Position property
          specifies that start within the buffer where to peer the first
          byte.</dd>
<dt>Returns:</dt>
<dd>number of bytes that were peered out of the buffer</dd>
<dt>Throws:</dt>
<dd><code><a href="PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</a></code> - thrown if ByteBuffer is not direct byte buffer type</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="peerStateAndData(org.jnetpcap.nio.JBuffer)">
<h3>peerStateAndData</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">peerStateAndData</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Peers the contents of the buffer directly with this packet. No copies are
 performed but the capture header, packet state and data are expected to be
 contained within the buffer with a certain layout as described below:
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing packet header, state and data</dd>
<dt>Returns:</dt>
<dd>number of bytes that were peered out of the buffer</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferHeaderAndDataFrom(org.jnetpcap.PcapHeader,java.nio.ByteBuffer)">
<h3>transferHeaderAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferHeaderAndDataFrom</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of header and packet buffer to a single newly allocated
 buffer. State is uninitialized. The packet's header and buffer's are peered
 with newly allocated buffer.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - source header</dd>
<dd><code>buffer</code> - source packet data buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferHeaderAndDataFrom(org.jnetpcap.PcapHeader,org.jnetpcap.nio.JBuffer)">
<h3>transferHeaderAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferHeaderAndDataFrom</span><wbr><span class="parameters">(<a href="../PcapHeader.html" title="class in org.jnetpcap">PcapHeader</a>&nbsp;header,
 <a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of header and packet buffer to a single newly allocated
 buffer. State is uninitialized. The packet's header and buffer's are peered
 with newly allocated buffer.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>header</code> - source header</dd>
<dd><code>buffer</code> - source packet data buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataFrom(byte[])">
<h3>transferStateAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataFrom</span><wbr><span class="parameters">(byte[]&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataFrom(java.nio.ByteBuffer)">
<h3>transferStateAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataFrom</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - Buffer containing capture header, packet state and data buffer
          sequentially in the buffer. Current buffer position points at the
          start of pcap header.</dd>
<dt>Returns:</dt>
<dd>number of bytes copied</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataFrom(org.jnetpcap.nio.JBuffer)">
<h3>transferStateAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataFrom</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of the buffer to new packet. All of the contents of the
 buffer are deep copied to new packet. The new packet allocates new memory
 for the packet contents, state and header if existing memory buffer is not
 large enough. Otherwise the existing memory buffer is overriden and reused.
 Existing buffers are not cleared before hand and may contain old data
 outside of the new header, state and packet data areas that are being
 overriden.
 <p>
 Supplied buffer layout expected:
 
 <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
 </p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataFrom(org.jnetpcap.packet.PcapPacket)">
<h3>transferStateAndDataFrom</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataFrom</span><wbr><span class="parameters">(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</span></div>
<div class="block">Deep copy of the supplied packet to this packet. Contents of the supplied
 packet such as pcap header, packet state and packet data are deep copied
 into newly allocated memory if necessary or existing memory buffer if it is
 large enough to hold the new packet with its complete state. In either
 case, the new packet will be stored with its header and state in a single
 contigues buffer.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>packet</code> - source packet from which to copy from</dd>
<dt>Returns:</dt>
<dd>number of bytes copied</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataTo(byte[])">
<h3>transferStateAndDataTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataTo</span><wbr><span class="parameters">(byte[]&nbsp;buffer)</span></div>
<div class="block">Copies contents of this packet to buffer. The packets capture header, state
 and packet data are copied to new buffer. After completion of this
 operation the complete contents and state of the packet will be transfered
 to the buffer. The layout of the buffer data will be as described below. A
 buffer with this type of layout is suitable for any transferStateAndData or
 peer methods for any buffers that are JMemory based. The buffer has to be
 large enough to hold all of the packet content as returned by method</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied <a href="#getTotalSize()"><code>getTotalSize()</code></a>. If the buffer is
         too small and a runtime exception may be thrown.
         <p>
         The buffer layout will look like the following:
 
         <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
         </p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataTo(java.nio.ByteBuffer)">
<h3>transferStateAndDataTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataTo</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" title="class or interface in java.nio" class="external-link">ByteBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of this packet to buffer. The packets capture header, state
 and packet data are copied to new buffer. After completion of this
 operation the complete contents and state of the packet will be transfered
 to the buffer. The layout of the buffer data will be as described below. A
 buffer with this type of layout is suitable for any transferStateAndData or
 peer methods for any buffers that are JMemory based. The buffer has to be
 large enough to hold all of the packet content as returned by method</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied <a href="#getTotalSize()"><code>getTotalSize()</code></a>. If the buffer is
         too small and a runtime exception may be thrown.
         <p>
         The buffer layout will look like the following:
 
         <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
         </p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataTo(org.jnetpcap.nio.JBuffer)">
<h3>transferStateAndDataTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataTo</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer)</span></div>
<div class="block">Copies contents of this packet to buffer. The packets capture header, state
 and packet data are copied to new buffer. After completion of this
 operation the complete contents and state of the packet will be transfered
 to the buffer. The layout of the buffer data will be as described below. A
 buffer with this type of layout is suitable for any transferStateAndData or
 peer methods for any buffers that are JMemory based. The buffer has to be
 large enough to hold all of the packet content as returned by method</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dt>Returns:</dt>
<dd>number of bytes copied <a href="#getTotalSize()"><code>getTotalSize()</code></a>. If the buffer is
         too small and a runtime exception may be thrown.
         <p>
         The buffer layout will look like the following:
 
         <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
         </p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataTo(org.jnetpcap.nio.JBuffer,int)">
<h3>transferStateAndDataTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataTo</span><wbr><span class="parameters">(<a href="../nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</a>&nbsp;buffer,
 int&nbsp;offset)</span></div>
<div class="block">Copies contents of this packet to buffer. The packets capture header, state
 and packet data are copied to new buffer. After completion of this
 operation the complete contents and state of the packet will be transfered
 to the buffer. The layout of the buffer data will be as described below. A
 buffer with this type of layout is suitable for any transferStateAndData or
 peer methods for any buffers that are JMemory based. The buffer has to be
 large enough to hold all of the packet content as returned by method</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>buffer</code> - buffer containing capture header, packet state and data buffer
          sequentially in the buffer</dd>
<dd><code>offset</code> - the offset</dd>
<dt>Returns:</dt>
<dd>number of bytes copied <a href="#getTotalSize()"><code>getTotalSize()</code></a>. If the buffer is
         too small and a runtime exception may be thrown.
         <p>
         The buffer layout will look like the following:
 
         <pre>
 +----------+-----+----+
 |PcapHeader|State|Data|
 +----------+-----+----+
 </pre>
 
         </p></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="transferStateAndDataTo(org.jnetpcap.packet.PcapPacket)">
<h3>transferStateAndDataTo</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">transferStateAndDataTo</span><wbr><span class="parameters">(<a href="PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</a>&nbsp;packet)</span></div>
<div class="block">Deep copy of the this packet to the supplied packet. Contents of the this
 packet such as pcap header, packet state and packet data are deep copied
 into the suppliedpacket, allocating memory if necessary or existing memory
 buffer if it is large enough to hold the new packet with its complete
 state. In either case, the packet will be stored with its header and state
 in a single contigues buffer in the supplied packet.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>packet</code> - destination packet to which to copy header, state and packet data</dd>
<dt>Returns:</dt>
<dd>number of bytes copied</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>
